---
title: "Union-Find (Disjoint-set)"
description: "Union-Find 자료구조에 대해 학습한 내용 정리"
createdAt: 2025-06-03 20:33:07
tags:
  - "algorithm"
  - "C++"
---

## 소개

Union-Find는 **상수 시간에 가까운 빠른 속도로 union 연산과 find 연산을 수행**하는 자료구조이다.

- union 연산: 두 그룹을 합치는 연산
- find 연산: 원소가 속한 그룹을 찾는 연산

## 배열을 이용해 구현한다면...

group이라는 배열을 두고, `group[i]`에 원소 i가 속한 그룹 번호를 기록하는 방식으로 구현할 수 있다.
`find(i)`의 경우, `group[i]`를 그대로 반환하면 되고, <strong>O(1)</strong>이 걸린다.
`union(a, b)`의 경우, 원소 b가 속한 그룹에 포함된 원소들의 그룹 번호를 원소 a가 속한 그룹의 번호로 변경해야 하므로 최악의 경우 <strong>O(N)</strong>이 걸린다.

union 연산 과정을 생각하면 다음과 같다.

|            |     |     |     |     |     |     |     |
| ---------- | --- | --- | --- | --- | --- | --- | --- |
| 원소번호 i | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| `group[i]` | 0   | 1   | 2   | 3   | 4   | 5   | 6   |

**[초기 상태]** 원소 0은 그룹 0에, 원소 1은 그룹 1에, 원소 2는 그룹 2에, 원소 3은 그룹 3에, …, 원소 6은 그룹 6에 속한다.

|            |     |     |     |     |     |       |     |
| ---------- | --- | --- | --- | --- | --- | ----- | --- |
| 원소번호 i | 0   | 1   | 2   | 3   | 4   | 5     | 6   |
| `group[i]` | 0   | 1   | 2   | 3   | 4   | **1** | 6   |

**[`union(1, 5)`]** 1이 속한 그룹과 5가 속한 그룹을 합친다. 그룹을 합칠 때 더 작은 번호로 그룹을 표현한다고 하면 `group[5]`만 1로 바꾸면 된다.

|            |     |     |     |       |     |     |     |
| ---------- | --- | --- | --- | ----- | --- | --- | --- |
| 원소번호 i | 0   | 1   | 2   | 3     | 4   | 5   | 6   |
| `group[i]` | 0   | 1   | 2   | **2** | 4   | 1   | 6   |

**[`union(2, 3)`]** 2가 속한 그룹과 3이 속한 그룹을 합친다. `group[3]`만 2로 바꾸면 된다.

|            |     |     |       |       |     |     |     |
| ---------- | --- | --- | ----- | ----- | --- | --- | --- |
| 원소번호 i | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
| `group[i]` | 0   | 1   | **1** | **1** | 4   | 1   | 6   |

**[`union(1, 3)`]** 1이 속한 그룹과 3이 속한 그룹을 합친다. 3이 속한 그룹은 (2, 3)으로 이루어져 있으므로, `group[2]`, `group[3]`을 모두 1로 변경해야 한다.

반면 Union-Find 자료구조를 활용하면, union, find 연산 모두 거의 상수 시간에 수행할 수 있으므로 배열을 이용해 구현하는 것보다 빠르다.

## Union-Find 구현

- Union-Find 자료구조에서 원소는 정점, 그룹은 트리로 표현한다.
- 트리의 루트가 그룹의 대표 역할을 한다. 즉, 루트 노드의 번호가 그룹의 식별자이다.

### 트리 구조 표현

트리 구조를 표현하기 위해서 각 정점의 부모를 기록하는 배열 `p`를 사용한다.

- `p[x]`는 정점 `x`의 부모의 번호이다.
- 처음에는 배열의 각 원소를 `-1`로 초기화했는데 이는 각각의 원소가 모두 루트라는 의미이다.
  - Union by rank를 적용할 때, 루트인 경우, `p` 배열에 `-1`이 아닌 음수 값을 저장할 수 있고 절댓값은 랭크 값을 의미한다.
  - 중요한 것은, `p[x]`가 음수이면 `x`가 루트는 의미이다.

```cpp title="union-find.cpp"
vector<int> p(1000005, -1);
```

### find 연산 구현

`find(x)`는 정점 x가 속한 그룹의 루트 번호를 반환하는 함수이다. 두 정점 a, b가 있을 때 `find(a)`와 `find(b)`가 같다면, 두 정점은 같은 그룹이라고 판단할 수 있다.

```cpp title="union-find.cpp"
int find(int x) {
  if (p[x] < 0) return x; // x가 루트이면 그대로 반환.
  return find(p[x]); // x가 루트가 아니라면, 재귀적으로 루트를 탐색.
}
```

### union 연산 구현

`uni(a, b)`는 정점 a가 속한 그룹과 정점 b가 속한 그룹을 하나로 합치는 함수이다.
C언어에서 공용체를 위해 union이라는 키워드가 사용되므로, 함수 이름을 union으로 지을 수 없다.

```cpp title="union-find.cpp"
bool uni(int a, int b) {
  a = find(a);
  b = find(b);

  // 이미 같은 그룹이면 false 반환.
  if (a == b) return false;

  // b가 속한 그룹을, a가 속한 그룹의 자식으로 두어서 합침.
  p[b] = a;
  return true;
}
```

### 시간복잡도

결국 find 함수가 전체 시간복잡도를 결정한다. Linked List 같은 **일자 형태의 트리가 생성**되면 **find 함수의 시간복잡도가 O(N)이 된다.**

### 최적화 - Union by rank

트리의 **높이를 낮추어야** 빠르게 연산할 수 있다.

**높이가 높은 트리의 자식으로 높이가 낮은 트리를 두어서 합치는 게,** 높이가 낮은 트리의 자식으로 높이가 높은 트리를 두어서 합치는 것보다 **전체적인 높이가 낮아진다.**

따라서 **union 연산에서 높이가 높은 트리의 자식으로 높이가 낮은 트리를 두어서 합치는 방식을 사용해 최적화**를 한다.

트리의 높이가 랭크이고, 랭크를 비교해서 높은 트리의 자식으로 낮은 트리를 두면 된다.

경로 압축이 추가되면, find 연산할 때 트리의 구조가 바뀌게 되어서 트리의 높이와 랭크가 다른 값을 갖게 될 수 있다.

```cpp title="union-find.cpp"
// p[x]가 음수인 경우, x는 루트이다.
// x가 루트일 때, p[x]의 절댓값으로 트리의 높이(랭크)를 표현할 것이다.
// 예를 들어서 p[3] = -6이면,
// 3번 정점이 루트이고, 트리의 높이(랭크)는 6이라는 의미이다.

bool uni(int a, int b) {
  a = find(a);
  b = find(b);
  if (a == b) return false;

  // 항상 (a의 랭크 >= b의 랭크)가 성립하게 swap.
  // b를 a의 자식으로 만들어서 합칠것이다.
  if (-p[a] < -p[b]) swap(a, b);
  // 높이(랭크)가 같은 트리를 합치는 경우, 루트가 될 a의 랭크를 1증가 시킨다.
  if (-p[a] == -p[b]) p[a]--;
  p[b] = a;
  return true;
}
```

### 최적화 - 경로 압축

**find 연산**을 수행할 때, **재귀적으로 거쳐 간 원소들을 모두 루트의 자식으로 만들어서 트리의 높이를 낮추는 최적화 방법**이다.

```cpp title="union-find.cpp"
int find(int x) {
  if (p[x] < 0) return x;
  // 루트 값 find(p[x])로, p[x]를 업데이트한다.
  return p[x] = find(p[x]);
}
```

### 최적화에 따른 시간복잡도

| 최적화                    | 시간복잡도                        |
| ------------------------- | --------------------------------- |
| Union by rank             | O(lgN)                            |
| 경로 압축                 | Amortized O(lgN)                  |
| Union by rank + 경로 압축 | Amortized O(α(N)), 거의 상수 시간 |

- Union by rank, 경로 압축 중 하나만 적용해도 union, find 연산의 속도가 빠르다.
- 둘 다 적용하면 사실상 상수 시간에 동작하는 union, find를 구현할 수 있다.
- Amortized O(lgN)에서 Amortized라는 것은 트리가 일자 형태라면 find 연산에 O(N), 경로 압축이 적용되어 루트의 자식에 대해 find 연산을 하면 O(1), 이런 식으로 다양한 상황이 있지만 전체적으로 합치면 O(lgN)에 가까운 시간복잡도라는 의미이다.

## 실행 시간 테스트

[Baekjoon 1717 집합의 표현](https://www.acmicpc.net/problem/1717) 문제로 실행 시간을 테스트 한 결과는 다음과 같다.

| 최적화                    | 시간복잡도 (ms) |
| ------------------------- | --------------- |
| 안함                      | 1584            |
| Union by rank             | 36              |
| 경로 압축                 | 36              |
| Union by rank + 경로 압축 | 32              |

Union by rank나 경로 압축 중 하나만 적용해도 빠르다.

## 참고

- [바킹독의 실전 알고리즘 부록 D - Union-Find](https://blog.encrypted.gg/1097)
