1:"$Sreact.fragment"
2:I[5123,["123","static/chunks/123-02cd6de926e73522.js","163","static/chunks/163-902588b035e0fb3d.js","934","static/chunks/934-0b94d196f075b05d.js","777","static/chunks/777-4178bdefcb1b0295.js","156","static/chunks/app/posts/%5B...slug%5D/page-c121fbdd8181a646.js"],""]
3:I[8241,["123","static/chunks/123-02cd6de926e73522.js","163","static/chunks/163-902588b035e0fb3d.js","934","static/chunks/934-0b94d196f075b05d.js","777","static/chunks/777-4178bdefcb1b0295.js","177","static/chunks/app/layout-69aec15873b63b1b.js"],"Menu"]
4:I[4910,[],""]
5:I[2244,[],""]
a:I[4550,[],""]
:HL["/_next/static/media/4974d0dc1d063735-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/4fa5cc234ac90208.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/bb3ef058b751a6ad-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/bfced24e9972e87a.css","style"]
:HL["/_next/static/css/db737e644f0f67e6.css","style"]
0:{"P":null,"b":"H3gvWlYbEFBWC6YVuM5Hk","p":"","c":["","posts"],"i":false,"f":[[["",{"children":["posts",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/bfced24e9972e87a.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/db737e644f0f67e6.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"ko","className":"__variable_ecc3fa __variable_1d1553 scroll-smooth antialiased","suppressHydrationWarning":true,"children":[["$","head",null,{"children":["$","script",null,{"dangerouslySetInnerHTML":{"__html":"(function p(){let a=localStorage.getItem(\"theme\");if(\"light\"===a||\"dark\"===a)return void b(a);function b(a){\"dark\"===a?document.documentElement.classList.add(\"dark\"):document.documentElement.classList.remove(\"dark\")}b(window.matchMedia(\"(prefers-color-scheme: dark)\").matches?\"dark\":\"light\")})();"}}]}],["$","body",null,{"children":["$","div",null,{"className":"px-4 min-h-dvh grid gap-y-6 grid-cols-[1fr_minmax(0,var(--content-max-width))_1fr] grid-rows-[var(--header-height)_1fr_var(--footer-height)]","children":[["$","header",null,{"className":"row-start-1 col-start-2 bg-background text-foreground z-10 sticky top-0 flex items-center justify-between","children":[["$","$L2",null,{"href":"/","children":"k2ep-ru2ning","data-slot":"button","className":"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 h-9 py-2 has-[>svg]:px-3 px-2 font-extrabold text-xl","ref":null}],["$","$L3",null,{}]]}],["$","div",null,{"className":"row-start-2 col-span-full","children":["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","main",null,{"className":"max-w-(--content-max-width) mx-auto px-(--content-horizontal-padding) flex flex-col gap-6","children":[["$","strong",null,{"className":"text-4xl text-brand font-bold","children":"404"}],["$","section",null,{"className":"flex flex-col gap-2","children":[["$","h1",null,{"className":"font-bold text-3xl","children":"페이지를 찾을 수 없어요"}],["$","p",null,{"className":"text-xl","children":"주소를 확인해주세요"}]]}],["$","$L2",null,{"href":"/","replace":true,"children":["Home으로 이동",["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-house size-4","aria-hidden":"true","children":[["$","path","5wwlr5",{"d":"M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8"}],["$","path","1d0kgt",{"d":"M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"}],"$undefined"]}]],"data-slot":"button","className":"inline-flex items-center justify-center whitespace-nowrap text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80 h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5 self-start","ref":null}]]}],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"px-(--content-horizontal-padding) row-start-3 col-start-2 border-t border-border flex flex-col justify-center items-center","children":"$L6"}]]}]}]]}]]}],{"children":["posts","$L7",{"children":["__PAGE__","$L8",{},null,false]},null,false]},null,false],"$L9",false]],"m":"$undefined","G":["$a",[]],"s":false,"S":true}
c:I[5831,[],"OutletBoundary"]
e:I[4246,[],"AsyncMetadataOutlet"]
10:I[5831,[],"ViewportBoundary"]
12:I[5831,[],"MetadataBoundary"]
13:"$Sreact.suspense"
6:["$","small",null,{"children":["© ",2025," ","k2ep-ru2ning"]}]
7:["$","$1","c",{"children":[null,["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}]
8:["$","$1","c",{"children":["$Lb",null,["$","$Lc",null,{"children":["$Ld",["$","$Le",null,{"promise":"$@f"}]]}]]}]
9:["$","$1","h",{"children":[null,[["$","$L10",null,{"children":"$L11"}],["$","meta",null,{"name":"next-size-adjust","content":""}]],["$","$L12",null,{"children":["$","div",null,{"hidden":true,"children":["$","$13",null,{"fallback":null,"children":"$L14"}]}]}]]}]
11:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
d:null
15:I[326,[],"IconMark"]
f:{"metadata":[["$","title","0",{"children":"글 | k2ep-ru2ning"}],["$","meta","1",{"name":"description","content":"글 목록 페이지입니다."}],["$","meta","2",{"name":"author","content":"k2ep-ru2ning"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","4",{"rel":"apple-touch-icon","href":"/apple-icon.png?572efa798f06f8a4","type":"image/png","sizes":"180x180"}],["$","$L15","5",{}]],"error":null,"digest":"$undefined"}
14:"$f:metadata"
16:I[1604,["123","static/chunks/123-02cd6de926e73522.js","163","static/chunks/163-902588b035e0fb3d.js","777","static/chunks/777-4178bdefcb1b0295.js","530","static/chunks/app/posts/page-af566f296e2a0b95.js"],"Posts"]
17:T378d,
## 목적

**시작 점으로부터 모든 정점까지 최단 거리를 구하는 그래프 알고리즘**이다.

- 방향 그래프인지, 무 방향 그래프인지 상관없다.
- **간선의 가중치가 음수이면 안 된다.** → 벨만포드 알고리즘을 쓰면 된다.

## 핵심 아이디어

도달할 수 있는 정점 중 **시작 점과 거리가 가장 가까운 정점의 최단 거리를 확정하는 과정을 반복하는 알고리즘**이다. 매번 Greedy 하게 선택하는 알고리즘이다.

## naive 다익스트라 알고리즘 구현

- 정점 V개, 간선 E개, 정점의 번호는 1 ~ V, 시작 정점의 번호는 S
- (크기가 V인) 최단 거리 테이블 `d`를 준비한다. (1차원 배열 `d`)
  - 다익스트라 알고리즘은 `d` 테이블을 채워나가는 과정이다.
- (크기가 V인) 시작점에서 해당 정점까지 최단 거리를 확정했는지 여부를 기록하는 `fixed` 테이블을 준비한다. (1차원 배열 `fixed`)

```
1. d[S]는 0으로 초기화. 나머지 정점 i에 대해 d[i]를 INF(무한대)로 초기화.
2. 모든 정점 i에 대해 fixed[i]도 false로 초기화.
3. d, fixed 테이블을 순회하면서 아직 최단 거리를 확정하지 않은 정점 중
   거리가 INF가 아니면서 가장 작은 정점 i를 찾음.
   3-1. 그런 정점이 없으면 알고리즘 끝냄.
   3-2. 그런 정점 i가 있으면,
        현재 d[i] 값이 시작점으로부터 정점 i까지의 최단 거리라는 의미로,
        fixed[i]를 true로 업데이트.
        정점 i까지의 최단 거리가 확정되었으므로,
        확정된 d[i]를 활용해
        정점 i의 인접한 정점 j에 대해 d[j]를 업데이트.
4. 3의 과정을 반복.
```

- `d` 테이블의 갱신(최단 거리가 될 수도 있는 값으로 업데이트)과 `fixed` 테이블의 갱신(최단 거리 확정)은 다른 시점에 별도로 발생한다.
- 최대 V 번의 최단 거리 확정이 발생한다. 최단 거리를 확정한 정점을 찾기 위해 크기가 V인 `d` 테이블을 탐색해야 하므로 전체적으로 O(V<sup>2</sup>) 소요된다. 그리고 정점의 최단 거리를 확정하고 나서 해당 정점과 연결된 간선들을 탐색하게 되므로, 알고리즘 전반에 걸쳐 E가 추가로 소요된다. 따라서 **시간복잡도는 O(V<sup>2</sup> + E)** 이다.
- “`d` 테이블을 탐색해 아직 최단 거리가 확정되지 않고 `d` 값이 가장 작은 정점 `i`의 최단 거리를 확정 → `i`의 인접 정점 `j`의 `d[j]`값 업데이트”를 반복해 `d` 테이블을 완성하는 것이 핵심 아이디어

```cpp title="naive-dijkstra.cpp"
#include <bits/stdc++.h>
using namespace std;

// INF 값은 문제의 크기에 맞게 결정하면 됨
const int INF = 100;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  // 정점 수 V
  // 간선 수 E
  int V, E;
  cin >> V >> E;

  // 인접 리스트 g
  // g[u]는 {v, cost}를 요소로 하는 vector
  // v는 u에서 출발해서 도착할 정점, cost는 간선 u -> v의 가중치
  vector<vector<pair<int, int>>> g(V + 5);
  for (int i = 0; i < E; i++) {
    int u, v, cost;
    cin >> u >> v >> cost;
    g[u].push_back({v, cost});
  }

  // 시작 정점
  const int start = 1;

  // 시작점으로부터 각 정점까지의 최단 거리를 기록할 d 테이블
  vector<int> d(V + 5, INF);

  // 시작점으로부터 해당 정점까지의 최단 거리가 확정되었는지 여부를 기록하는
  // fixed 테이블
  vector<bool> fixed(V + 5, false);

  // d[start]만 0으로 초기화.
  // 아직 start의 최단 거리가 0으로 확정하지 않은 상태.
  // 최단 거리 갱신(d 테이블 값 갱신)과 최단 거리 확정(fixed 테이블 값 갱신)은
  // 별도로 처리됨
  d[start] = 0;

  while (true) {
    // d 테이블에서
    // 아직 최단 거리를 확정하지 않은 정점 중
    // 최소값을 갖는 정점 cur를 선택
    int cur = -1;
    for (int i = 1; i <= V; i++) {
      if (fixed[i]) {
        // 이미 최단 거리 확정한 정점이면...
        continue;
      }
      if (cur == -1 || d[i] < d[cur]) {
        // 첫 정점 혹은 더 작은 값을 갖는 정점 i를 발견했을 때, cur 갱신
        cur = i;
      }
    }
    if (cur == -1 || d[cur] == INF) {
      // 더 이상 선택할 수 있는 정점이 없을 때, 알고리즘 중단
      // (모두 선택했거나 또는 선택한 정점의 값이 INF인 경우)
      break;
    }
    // 선택한 cur 정점의 최단 거리 확정
    fixed[cur] = true;
    // cur 정점과 연결된 간선을 확인해
    // cur 정점과 인접한 정점의 최단 거리 갱신
    for (const auto& [u, cost] : g[cur]) {
      if (fixed[u]) {
        continue;
      }
      d[u] = min(d[cur] + cost, d[u]);
    }
  }

  // d 테이블 출력
  for (int i = 1; i <= V; i++) {
    cout << d[i] << ' ';
  }

  return 0;
}
```

## 최소 힙을 활용한 다익스트라 알고리즘 구현

**매번 O(V)에 `d` 테이블을 선형 탐색해서 최단 거리를 확정할 정점을 찾는 대신, 최소 힙에서 정점 정보를 빠르게 꺼내서 그 정점의 최단 거리를 확정할 수 있는지 체크**한다.

이를 위해서 정점 `i`의 최단 거리 테이블값 `d[i]`이 업데이트될 때마다 정점 `i`와 `d[i]` 값을 최소 힙에 넣어 둔다.

```cpp title="dijkstra.cpp" showLineNumbers {83-85}
/**
 * https://www.acmicpc.net/problem/1753
 * 최단경로
 */

#include <bits/stdc++.h>
using namespace std;

// 무한대 값을 의미.
// (정점 수) * (가중치 최댓값)으로 설정.
const int INF = 20000 * 10;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  // V: 정점 수, E: 간선 수
  int V, E;
  cin >> V >> E;

  // K: 시작점
  int K;
  cin >> K;

  // 인접 리스트 형태의 그래프 g
  // g[i]: {w, j}를 요소로 하는 리스트
  // w: 간선 i -> j의 가중치
  vector<vector<pair<int, int>>> g(V + 5);
  for (int i = 0; i < E; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    g[u].push_back({w, v});
  }

  // 최소 힙을 활용한 다익스트라 알고리즘
  // 매번 O(V)에 d 테이블을 선형 탐색헤서
  // 최단 거리를 확정할 정점을 찾는 방법 대신,
  // 최소 힙에서 정점 정보를 꺼내서,
  // 그 정점의 최단 거리를 확정할 수 있는지 체크한다.
  // 이를 위해서
  // 정점 i의 최단 거리 테이블값 d[i]의 업데이트가
  // 발생할 때마다 { d[i], i } 값을
  // 최소 힙에 넣어둔다.

  // 최단 거리 테이블 d
  vector<int> d(V + 5, INF);

  // {시작점으로부터 정점 i까지 거리, 정점 i} 형태의 pair를
  // 저장하기 위한 최소힙.
  // 거리를 기준으로 작은 값부터 pop 하도록 만들고 싶어서,
  // {거리, 정점} 형태로 저장.
  // STL의 priority_queue는 세 번째로 전달한 정렬 기준을 이용해 정렬한 후,
  // 마지막 끝값부터 pop 한다.
  // 정렬 기준으로 greater<pair<int, int>>을 주었기 때문에
  // pair<int, int>를 내림차순으로 정렬한 후
  // 마지막 끝값부터 pop 하면 크기가 작은 pair<int, int>부터
  // pop 되므로 최소 힙이 된다.
  priority_queue<pair<int, int>, vector<pair<int, int>>,
                 greater<pair<int, int>>>
      minHeap;

  // 최소 힙을 활용한 다익스트라에서도
  // 최단 거리 테이블 갱신과 최단 거리 확정을 따로 발생.

  // 최단 거리 테이블 갱신.
  // d[i]를 갱신하면, {d[i], i}를 최소 힙에 push.
  d[K] = 0;
  minHeap.push({d[K], K});

  // 간선 개수만큼 최소 힙에 정점 정보가 들어갔다가 나오므로
  // O(ElgE)
  while (!minHeap.empty()) {
    // 선형 탐색 없이
    // 최단 거리 확정 지을 정점 정보를
    // 최소 힙에서 pop
    auto [cost, cur] = minHeap.top();
    minHeap.pop();

    // d[cur]값이 cost보다 작을 수 있음.
    // 이 경우, 쓸모없는 정점 정보라서 버림.
    // 시작점에서 cur로 가는 비용이 cost보다 더 작은 경로가 발견되어,
    // d[cur]가 cost보다 더 작은 값으로 업데이트 된 케이스.
    if (cost != d[cur]) {
      continue;
    }

    // 위의 검사를 통과했다면
    // 시작점으로부터 cur까지 최단 거리가 cost(즉, d[cur])로 확정

    // cur까지의 확정된 최단 거리를 활용해,
    // d 테이블 갱신 및 최소 힙에 정점 정보 push
    for (auto [w, nxt] : g[cur]) {
      if (d[cur] + w >= d[nxt]) {
        continue;
      }
      d[nxt] = d[cur] + w;
      minHeap.push({d[nxt], nxt});
    }
  }

  for (int i = 1; i <= V; i++) {
    if (d[i] == INF) {
      cout << "INF" << '\n';
    } else {
      cout << d[i] << '\n';
    }
  }

  return 0;
}
```

[백준 1753 최단경로](https://www.acmicpc.net/problem/1753) 문제의 답안이다.

83 - 85번째 줄에서 **최소 힙에서 꺼낸 정점 `cur`와 `cur`까지의 거리 `cost`가 의미가 있는지 체크**하는 부분의 코드를 조심해야 한다.

- **`cost`와 `d[cur]`의 값이 다르면 이번에 최소 힙에서 꺼낸 `{ cost, cur }` 정보는 의미가 없다.**
- `{ cost, cur }` 정보가 최소 힙에 push 되고 나서, `cur`로 가는 비용이 `cost`보다 더 작은 경로가 발견된 경우이다.
- `{ cost, cur }` 정보가 최소 힙에 push 되고 나서, `cur`로 가는 비용이 `cost_s`로 `cost`보다 더 작은 비용을 갖는 경로가 발견되었다고 하자. 그러면, `d[cur]`는 `cost_s`로 업데이트되고, `{ cost_s, cur }` 정보가 최소 힙에 push 된다. 그리고 이 정보는 `{ cost, cur }` 보다 비용이 적어 최소 힙에서 먼저 pop 된다. (이때 `d[cur]`와 `cost_s`가 같아서 `cur`의 최단 거리를 `cost_s`로 확정하게 된다.)
- 반면, **`cost`와 `d[cur]`의 값이 같다면 `cur`까지의 최단 거리를 `cost`로 확정한다.**
- 최소 힙에서 꺼낸 정보와 `d` 테이블의 정보를 비교해, 특정 정점의 최단 거리가 확정되었는지 판단할 수 있으므로, **별도의 `fixed` 배열을 관리할 필요가 없다.**

간선의 개수만큼 최소 힙에 (거리, 정점) 정보가 들어갔다가 나오므로, 시간복잡도는 **O(ElgE)** 이다.

## 최단 경로 추적

정점 `i`의 최단 경로를 확정하고, 정점 `i`를 거쳐서 `i`의 인접한 정점 `j`로 가는 비용이 기존의 `d[j]`보다 작아서 `d[j]`를 업데이트하는 경우를 생각하자. 어떤 직전 정점으로부터 정점 `j`로 도달할 때 `d[j]`의 값이 업데이트되었는지 기록하면, 시작 점에서 `j`로 오는 최단 경로를 추적할 수 있다.

이를 위해, **어떤 정점에 최단 경로로 도달할 때 직전에 방문해야 할 정점을 기록하는 `pre` 배열**을 두었다. 그리고 정점 `x`에 대해 `d[x]`를 업데이트할 때, `pre[x]`도 함께 업데이트한다.

다익스트라 알고리즘을 수행한 후,

```
정점 x → pre[x] → pre[pre[x]] → … → 시작점
```

처럼 끝점에서 시작 점으로 경로를 추적할 수 있다. 시작 점에서 출발하는 경로가 필요하면 경로를 뒤집으면 된다.

```cpp showLineNumbers {71, 81-87}
/**
 * https://www.acmicpc.net/problem/11779
 * 최소비용 구하기 2
 *
 * 다익스트라 알고리즘에서 경로 추적하기
 */

#include <bits/stdc++.h>
using namespace std;

const int INF = 1e3 * 1e5;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  // 정점 n개
  // 간선 m개
  int n, m;
  cin >> n >> m;

  // 인접 리스트 형태의 그래프 g
  // g[u]: {w, v}를 요소로 하는 리스트
  // w: 간선 u -> v의 가중치
  vector<vector<pair<int, int>>> g(n + 5);
  for (int i = 0; i < m; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    g[u].push_back({w, v});
  }

  // 시작 정점 st
  // 끝 정점 en
  int st, en;
  cin >> st >> en;

  vector<int> d(n + 5, INF);
  // 최단 경로 추적을 위함
  // pre[i]: 시작점으로부터 i로 최단 거리로 가기 위해, i 직전에 pre[i]를 방문
  // d[i] 값을 업데이트할 때, pre[i]값도 같이 업데이트
  vector<int> pre(n + 5);
  priority_queue<pair<int, int>, vector<pair<int, int>>,
                 greater<pair<int, int>>>
      min_heap;

  d[st] = 0;
  min_heap.push({d[st], st});
  // 시작점의 직전 정점은 없으므로,
  // d[st]는 업데이트하지만, pre[st]는 업데이트 하지 않음.

  while (!min_heap.empty()) {
    auto [cur_cost, cur] = min_heap.top();
    min_heap.pop();

    if (d[cur] != cur_cost) {
      continue;
    }

    for (auto [w, nxt] : g[cur]) {
      if (d[cur] + w >= d[nxt]) {
        continue;
      }
      // 최단 거리가 확정된 정점 cur의 정보로
      // d 테이블 업데이트할 때,
      // 최소 힙에 정점 정보를 넣고,
      // pre 테이블도 업데이트함.
      d[nxt] = d[cur] + w;
      min_heap.push({d[nxt], nxt});
      // d[nxt]가 d[cur]를 활용해 계산되었으므로
      // nxt 직전의 정점을 cur로 기록
      pre[nxt] = cur;
    }
  }

  // st -> en 최단 거리 출력
  cout << d[en] << '\n';

  // pre 배열을 활용해서 st -> en 최단 거리 추적
  // en -> pre[en] -> pre[pre[en]] -> ... -> st
  // 순으로 추적 가능
  vector<int> path;
  int cur = en;
  while (cur != st) {
    path.push_back(cur);
    cur = pre[cur];
  }
  path.push_back(st);
  // en -> st 경로를 뒤집기
  reverse(path.begin(), path.end());
  // 경로 크기 출력
  cout << path.size() << '\n';
  // 경로에 속한 정점 출력
  for (int v : path) cout << v << ' ';
  return 0;
}
```

[백준 11779 최소비용 구하기 2](https://www.acmicpc.net/problem/11779) 문제의 답안이다.

자세히 살펴봐야 할 코드는

- 71번째 줄에서, `d[nxt]`를 업데이트 할 때 `pre[nxt]`도 `cur`로부터 파생되었다고 기록하는 부분
- 81 - 87번째 줄에서, 목적지 정점에서 시작 정점으로 경로를 추적하는 부분

이다.

## 참고

- [바킹독의 실전 알고리즘 0x1D강 - 다익스트라 알고리즘](https://blog.encrypted.gg/1037)
18:T104c,
## 문제

tag search parameter에 `"C++"`이라는 문자열을 넣었는데, Next.js 애플리케이션에서 `"C  "`로 해석되는 문제가 발생했다.

`/posts?tag=C++` 주소를 요청했을 때, tag 값이 `"C++"`이 아니라 `"C  "`가 되어서 태그 기반의 글 필터링이 제대로 동작하지 않았다.

## 원인

Next.js에서 제공하는 `useSearchParams` hook을 이용해 tag search parameter를 조회했다. 이 hook은 `URLSearchParams` 타입의 객체를 반환한다.

그런데, [`URLSearchParams`는 `"+"` 문자를 공백으로 디코딩한다.](https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams#%EB%8D%94%ED%95%98%EA%B8%B0_%EA%B8%B0%ED%98%B8_%EB%B3%B4%EC%A1%B4%ED%95%98%EA%B8%B0) 그래서 `"C++"`라는 tag search parameter 값이 `"C  "`으로 조회되었다.

tag search parameter를 `"C++"`로 하는 url 인스턴스를 `URL` class로 생성해서 테스트해 봤다.

```js
const url = new URL(
  "https://k2ep-ru2ning.github.io/posts?tag=C++&tag=상태 관리&page=1",
);
console.log(`url.search:`, url.search);
console.log(`url.searchParams.getAll("tag"):`, url.searchParams.getAll("tag"));
```

![cpp-search-parameter-decoding-test](/images/posts/2025/url-decoding-troubleshooting/cpp-search-parameter-decoding-test.webp)

`url.search`로 인코딩된 search parameter 문자열을 얻을 수 있다. `"C++"`는 `"C++"`로 인코딩되었다. 반면 한글 문자열인 `"상태 관리"`는 `"%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC"`로 인코딩되었다.

`url.searchParams`로, `useSearchParams` hook이 반환하는 것과 동일한 `URLSearchParams` 타입의 객체를 얻을 수 있다. `get`, `getAll` 등의 메서드를 통해 특정 search parameter의 값을 쉽게 조회할 수 있다. **조회 과정에서 디코딩도 알아서 해준다.**

`url.searchParams.getAll("tag")`가 반환하는 값에서 `"C++"`로 인코딩된 문자열이 `"C  "`로 디코딩된 것을 확인 할 수 있다. 반면 읽기 힘든 문자열로 인코딩 되었던 한글 문자열은 원래 값인 `"상태 관리"`로 잘 디코딩 되었다.

## 해결

**`"C++"`라는 문자열을 search parameter에 그대로 쓰지 않고, `encodeURIComponent` 함수를 이용해 `"C%2B%2B"`라는 문자열로 인코딩해서 문제를 해결했다.** `URLSearchParams`의 `get`이나 `getAll` 메서드로 조회하면 `"C++"`이라는 값으로 잘 조회된다.

```js
const url = new URL(
  `https://k2ep-ru2ning.github.io/posts?tag=${encodeURIComponent("C++")}`,
);
console.log(`url.search:`, url.search);
console.log(`url.searchParams.get("tag"):`, url.searchParams.get("tag"));
```

![encoded-cpp-search-parameter-decoding-test.webp](/images/posts/2025/url-decoding-troubleshooting/encoded-cpp-search-parameter-decoding-test.webp)

<strong>
`"C++"`를 인코딩한 문자열 `"C%2B%2B"`에는 `"+"` 문자가 없어서 `URLSearchParams`가 `"C++"`로 잘 디코딩한다.
</strong>

여기서 `encodeURI`가 아니라 `encodeURIComponent`로 인코딩해야 `"C++"`의 `"+"`가 제대로 인코딩된다.

- `encodeURI("C++")` → `"C++"`
- `encodeURIComponent("C++")` → `"C%2B%2B"`

`encodeURI`는 `"https://k2ep-ru2ning.github.io/posts?tag=개발 환경 설정"` 같은 **전체 URL을 인코딩할 때 사용한다.** 따라서 한글처럼 URL 상에 쓸 수 없는 문자만 인코딩하고, `:`, `?`, `=`, `&`, `#` 처럼 URL 상에서 구분자로 사용되는, 허용된 문자들을 별도로 인코딩하지 않는다.

반면, `encodeURIComponent`는 **search parameter처럼 URL의 구성요소 각각을 인코딩할 때 사용한다.** 한글처럼 URL 상에 쓸 수 없는 문자뿐만 아니라 `#`, `$`, `&`, `+`, `,`, `/`, `:`, `;`, `=`, `?`, `@`도 인코딩한다. URL 구성요소에 구분자 역할을 하는 문자가 있다면, URL의 구조가 모호해지기 때문이다.

## 참고

- [MDN URLSearchParams - 더하기 기호 보존하기](https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams#%EB%8D%94%ED%95%98%EA%B8%B0_%EA%B8%B0%ED%98%B8_%EB%B3%B4%EC%A1%B4%ED%95%98%EA%B8%B0)
- [모던 JavaScript 튜토리얼 - URL objects](https://ko.javascript.info/url)
19:T1f44,
## 목적

그래프에서 **모든 정점 쌍 사이의 최단 거리를 구하는 알고리즘**

- 방향 그래프인지, 무방향 그래프인지 상관없음
- 간선의 가중치가 음수여도 됨
- 음수 사이클은 있으면 안 됨

그래프의 정점 개수가 V개일 때 **O(V<sup>3</sup>)** 시간 복잡도

## 아이디어

정점 `i`에서 정점 `j`로 가는 최단 거리를 기록하기 위한 2차원 배열 `dist`를 준비한다.

`dist` 배열을 초기화한다.

- 간선 `a` → `b`의 비용이 `cost`일 때, `dist[a][b]`를 `cost`로 초기화
  (`a` → `b`로 가는 간선이 여러 개이면 그 중 최소 비용으로 `dist[a][b]`를 업데이트)
- `dist[i][i]`는 `0`으로 초기화, 그 외의 값은 `INF`(무한대)로 초기화

**`dist` 배열의 상태를 점진적으로 업데이트**한다.
**중간에 거쳐 갈 정점 `k` 개를 고려해 `dist`를 채워둔 상황에서, 추가로 중간에 정점 `k+1`을 거쳐 갈 수 있다고 고려해 `dist`를 업데이트하는 것**이 핵심 아이디어이다.

```
중간에 아무 정점을 거치지 않고, 정점 i에서 j로 가는 최단 거리를 기록하는 dist
↓
중간에 아무 정점을 거치지 않거나 정점 1을 거쳐서, 정점 i에서 j로 가는 최단 거리를 기록하는 dist
↓
중간에 아무 정점을 거치지 않거나 정점 1 또는 정점 2를 거쳐서, 정점 i에서 j로 가는 최단 거리를 기록하는 dist
↓
...
↓
중간에 아무 정점을 거치지 않거나 정점 1 또는 정점 2 또는 ... 또는 정점 V를 거쳐서, 정점 i에서 j로 가는 최단 거리를 기록하는 dist
```

## 예시 코드

```c++ showLineNumbers {18, 41-50, 53-63}
/**
 * https://www.acmicpc.net/problem/11404
 * 플로이드
 */

#include <bits/stdc++.h>
using namespace std;

// 정점 a에서 정점 b로 가는 경로가 없을 때, 비용을 INF로 표현
// INF 값은 대략 (정점 수 * 가중치의 최대값)으로 정하면 됨
// 경로에 같은 정점이 여러 번 등장하면 사이클이 있다는 의미고
// 이런 경로는 최단 경로가 아님
// 최단 경로에는 최악의 경우 모든 정점이 한 번씩 등장하고,
// 최단 경로의 간선 수는 (정점 수 - 1)
// ((정점 수 - 1) * 가중치의 최대값) 보다 크게 INF를 설정하면 됨
// 플로이드 알고리즘에서 INF끼리 더할 수 있으므로
// 오버플로우를 조심해야 함
const int INF = 1e7;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  // n: 정점 수
  // m: 간선 수
  int n, m;
  cin >> n >> m;

  // 플로이드를 사용한다면
  // dist 배열만 잘 관리하면 되므로
  // 그래프를 굳이 인접 리스트 형태로 관리할 필요가 없음

  // dist[i][j]: 정점 i에서 정점 j로 가는 최단 경로
  // dist 배열 초기화 과정
  // - (간선 정보를 활용해서)
  //   정점 a -> 정점 b로 가는 간선이 있다면
  //   가장 적은 비용의 간선을 선택하고,
  //   그 비용으로 dist[a][b]를 설정
  // - dist[i][i]는 0으로 설정
  // - 그외의 dist[i][j]는 INF로 설정
  vector<vector<int>> dist(n + 5, vector<int>(n + 5, INF));
  for (int i = 0; i < m; i++) {
    int a, b, c;  // 간선 a -> b의 비용 c
    cin >> a >> b >> c;
    // dist[a][b] = c;
    dist[a][b] = min(dist[a][b], c);  // a -> b 간선이 여러 개일 수 있음
  }
  for (int i = 1; i <= n; i++) {
    dist[i][i] = 0;
  }

  // 플로이드. O(n^3)
  for (int k = 1; k <= n; k++) {  // 새롭게 고려할, 중간에 거쳐 갈 수 있는 정점 k
    for (int i = 1; i <= n; i++) {    // 시작 정점 i
      for (int j = 1; j <= n; j++) {  // 도착 정점 j
        // 기존의 i -> j로 가는 최소 비용 dist[i][j]와
        // 중간에 정점 k를 거쳐서 가는 최소 비용 dist[i][k] + dist[k][j]를
        // 비교해서 더 작은 값을 선택
        // min 함수에 의해 dist[i][j] 값은 항상 INF 이하로 유지됨
        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
      }
    }
  }

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      int cost = dist[i][j] == INF ? 0 : dist[i][j];
      cout << cost << ' ';
    }
    cout << '\n';
  }

  return 0;
}
```

[백준 11404 플로이드](https://www.acmicpc.net/problem/11404) 문제의 답안이다.

주의해야 할 코드는

- 18번째 줄의 INF 상수를 정하는 부분
- 41 - 50번째 줄에서 dist 배열을 초기화하는 부분
- 53 - 63번째 줄에서 3중 for 문으로 플로이드를 구현한 부분

이다.

## 경로 구하기

추가로, 2차원 배열 `nxt`를 활용한다.

- `nxt[i][j]`: 정점 `i`에서 `j`로 가는 최단 경로가 있을 때, **정점 `i`(출발점) 다음으로 방문해야 할 정점을 기록**
- 정점 `i`에서 `j`로 가는 최단 경로가 있다면, `i` → `nxt[i][j]` → `nxt[nxt[i][j]][j]` → ... → `j` 이런 식으로 경로를 구할 수 있다.

```cpp showLineNumbers {22, 26-31, 40-46, 63-76}
/**
 * https://www.acmicpc.net/problem/11780
 * 플로이드 2
 */

#include <bits/stdc++.h>
using namespace std;

const int INF = 1e7;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  int n, m;
  cin >> n >> m;

  vector<vector<int>> dist(n + 5, vector<int>(n + 5, INF));
  // nxt[i][j]
  // 정점 i에서 정점 j로 최단 거리로 이동하기 위해
  // i 다음으로 가야 할 첫 번째 정점을 기록하는 배열
  vector<vector<int>> nxt(n + 5, vector<int>(n + 5));
  for (int i = 0; i < m; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    if (c < dist[a][b]) {
      dist[a][b] = c;
      // dist[a][b]를 c로 업데이트할 때,
      // a 다음에 가야 할 위치를 b로 설정
      nxt[a][b] = b;
    }
  }
  for (int i = 1; i <= n; i++) {
    dist[i][i] = 0;
  }

  for (int k = 1; k <= n; k++) {
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= n; j++) {
        if (dist[i][k] + dist[k][j] < dist[i][j]) {
          dist[i][j] = dist[i][k] + dist[k][j];
          // k를 거쳐서 가는 게 더 빠른 경우, nxt[i][j]도 업데이트 필요.
          // i에서 k로 가기 위해 다음으로 가야 할 정점 nxt[i][k]로
          // nxt[i][j]를 업데이트.
          nxt[i][j] = nxt[i][k];
        }
      }
    }
  }

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      int cost = dist[i][j] == INF ? 0 : dist[i][j];
      cout << cost << ' ';
    }
    cout << '\n';
  }

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
      if (dist[i][j] == 0 || dist[i][j] == INF) {
        cout << 0 << '\n';
      } else {
        // i -> j 최단 경로가 존재하고, 길이가 1 이상인 경우.
        // nxt 배열을 활용해 경로를 출력
        int cur = i;
        vector<int> path{cur};  // 시작점을 경로에 추가
        while (cur != j) {      // cur가 목적지가 아니라면...
          cur = nxt[cur][j];    // 최단 경로 안에서 다음 정점으로 이동 후
          path.push_back(cur);  // 경로에 추가
        }
        cout << path.size() << ' ';  // 경로 길이 출력
        // 경로 출력
        for (const int v : path) cout << v << ' ';
        cout << '\n';
      }
    }
  }

  return 0;
}

```

[백준 11780 플로이드 2](https://www.acmicpc.net/problem/11780) 문제의 답안이다.

주의해야 할 코드는

- 22번째 줄의 `nxt` 배열 선언
- 26 - 31번째 줄에서 `dist[a][b]` 값을 초기화할 때, `nxt[a][b]` 값도 초기화하는 부분
- 40 - 46번째 줄에서 `k`를 거쳐서 `i` → `j`로 가는 게 비용이 더 적은 경우, `nxt[i][j]`를 `nxt[i][k]`로 업데이트하는 코드
- 63 - 76번째 줄에서 최단 경로가 존재하고 길이가 1 이상인 경우, `nxt` 배열을 이용해 `i`에서 `j`까지의 경로를 추적하는 코드

이다.

## 참고

- [바킹독의 실전 알고리즘 0x1C강 - 플로이드 알고리즘](https://blog.encrypted.gg/1035)
1a:Tfa6,
Next.js 문서에서 `getStaticPaths` 함수의 타입 검사를 위해 `satisfies` 연산자를 활용하는 코드를 봤다.

```ts {12}
export const getStaticPaths = (async () => {
  return {
    paths: [
      {
        params: {
          name: "next.js",
        },
      }, // See the "paths" section below
    ],
    fallback: true, // false or "blocking"
  };
}) satisfies GetStaticPaths;
```

`GetStaticPaths` **타입을 type annotation으로 추가하는 것과 satisfies 연산자로 적용하는 것의 차이점**이 궁금했다.

## 예제

```ts {4-5, 8}
const palette = {
  red: [255, 0, 0],
  green: "#00ff00",
  // blue 프로퍼티 이름 오타!. 타입 검사로 검출하고 싶음.
  bleu: [0, 0, 255],
};

console.log(palette.green.toUpperCase());
```

색깔을 정의하는 `palette` 객체를 만들었다.

![example](/images/posts/2025/satisfies-operator/example.webp)

`{ red: number[]; green: string; bleu: number[]; }` 타입으로 추론이 잘 된다. 그리고, `palette`의 `green` 프로퍼티에 접근해서 `string` method를 사용하고 있다. 원래 `blue`라는 프로퍼티를 만들고 싶었는데 오타가 났다. **오타를 타입 검사로 해결**하고 싶다.

## type annotation

타입 검사를 하기 위해서는 변수를 선언할 때, 타입을 선언하면 된다

```ts {5}
type Colors = "red" | "green" | "blue";

type RGB = [red: number, green: number, blue: number];

const palette: Record<Colors, RGB | string> = {
  red: [255, 0, 0],
  green: "#00ff00",
  bleu: [0, 0, 255],
};

console.log(palette.green.toUpperCase());
```

`palette` 객체의 프로퍼티 키는 `"red"`, `"green"`, `"blue"` 중 하나이고, 프로퍼티 값은 `[number, number, number]` 타입이거나 `string` 타입이다.

따라서 `palette` 변수의 타입을 `Record<Colors, RGB | string>` 으로 선언하면 된다.

그러면, **`bleu`라는 오타를 잡아낼 수 있다.**

![type-annotation](/images/posts/2025/satisfies-operator/type-annotation.webp)

하지만 모든 프로퍼티 값이 `string | RGB` 타입이 되기 때문에, **원래 잘 동작하던 `palette.green.toUpperCase()` 코드에서 타입 에러가 발생한다.**

type annotation이 아닌 satisfies 연산자를 쓰면 이런 문제를 해결할 수 있다.

## satisfies 연산자

```ts {9, 11}
type Colors = "red" | "green" | "blue";

type RGB = [red: number, green: number, blue: number];

const palette = {
  red: [255, 0, 0],
  green: "#00ff00",
  bleu: [0, 0, 255],
} satisfies Record<Colors, RGB | string>;

console.log(palette.green.toUpperCase());
```

type annotation을 지웠다.

그리고 satisfies 연산자로 주어진 expression이 `Record<Colors, RGB | string>` 타입인지 검증했다.

![satisfies-1](/images/posts/2025/satisfies-operator/satisfies-1.webp)

`bleu` 오타를 잘 잡아냈고, `palette.green.toUpperCase()` 코드에서도 `palette.green`이 `string` 타입으로 추론 되어 타입 에러가 발생하지 않았다.

![satisfies-2](/images/posts/2025/satisfies-operator/satisfies-2.webp)

`bleu` 오타를 해결하고 palette 변수의 타입이 어떻게 추론되는지 확인하면, `{ red: [number, number, number]; green: string; blue: [number, number, number]; }` 타입으로 추론되고, 이 타입은 `Record<Colors, RGB | string>` 타입과 매칭되는(호환되는) 타입이다.

<strong>(expression E `satisfies` type T)</strong>는 **E가 T type인지 체크는 하지만, E의 타입을 T로 만들지 않는다. 이게 type annotation을 사용했을 때와 차이점이다.**

## 정리

**타입 추론을 유지하면서 expression의 타입을 검사할 필요가 있을 때** `satisfies` 연산자를 유용하게 사용할 수 있다.

(설정과 관련된) 객체를 만들고 타입을 검사하는 상황에 유용할 것 같다.

## 참고

[타입스크립트 공식문서 satisfies operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html#the-satisfies-operator)
1b:T1f4d,
## 소개

Union-Find는 **상수 시간에 가까운 빠른 속도로 union 연산과 find 연산을 수행**하는 자료구조이다.

- union 연산: 두 그룹을 합치는 연산
- find 연산: 원소가 속한 그룹을 찾는 연산

## 배열을 이용해 구현한다면...

group이라는 배열을 두고, `group[i]`에 원소 i가 속한 그룹 번호를 기록하는 방식으로 구현할 수 있다.
`find(i)`의 경우, `group[i]`를 그대로 반환하면 되고, <strong>O(1)</strong>이 걸린다.
`union(a, b)`의 경우, 원소 b가 속한 그룹에 포함된 원소들의 그룹 번호를 원소 a가 속한 그룹의 번호로 변경해야 하므로 최악의 경우 <strong>O(N)</strong>이 걸린다.

union 연산 과정을 생각하면 다음과 같다.

|            |     |     |     |     |     |     |     |
| ---------- | --- | --- | --- | --- | --- | --- | --- |
| 원소번호 i | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| `group[i]` | 0   | 1   | 2   | 3   | 4   | 5   | 6   |

**[초기 상태]** 원소 0은 그룹 0에, 원소 1은 그룹 1에, 원소 2는 그룹 2에, 원소 3은 그룹 3에, …, 원소 6은 그룹 6에 속한다.

|            |     |     |     |     |     |       |     |
| ---------- | --- | --- | --- | --- | --- | ----- | --- |
| 원소번호 i | 0   | 1   | 2   | 3   | 4   | 5     | 6   |
| `group[i]` | 0   | 1   | 2   | 3   | 4   | **1** | 6   |

**[`union(1, 5)`]** 1이 속한 그룹과 5가 속한 그룹을 합친다. 그룹을 합칠 때 더 작은 번호로 그룹을 표현한다고 하면 `group[5]`만 1로 바꾸면 된다.

|            |     |     |     |       |     |     |     |
| ---------- | --- | --- | --- | ----- | --- | --- | --- |
| 원소번호 i | 0   | 1   | 2   | 3     | 4   | 5   | 6   |
| `group[i]` | 0   | 1   | 2   | **2** | 4   | 1   | 6   |

**[`union(2, 3)`]** 2가 속한 그룹과 3이 속한 그룹을 합친다. `group[3]`만 2로 바꾸면 된다.

|            |     |     |       |       |     |     |     |
| ---------- | --- | --- | ----- | ----- | --- | --- | --- |
| 원소번호 i | 0   | 1   | 2     | 3     | 4   | 5   | 6   |
| `group[i]` | 0   | 1   | **1** | **1** | 4   | 1   | 6   |

**[`union(1, 3)`]** 1이 속한 그룹과 3이 속한 그룹을 합친다. 3이 속한 그룹은 (2, 3)으로 이루어져 있으므로, `group[2]`, `group[3]`을 모두 1로 변경해야 한다.

반면 Union-Find 자료구조를 활용하면, union, find 연산 모두 거의 상수 시간에 수행할 수 있으므로 배열을 이용해 구현하는 것보다 빠르다.

## Union-Find 구현

- Union-Find 자료구조에서 원소는 정점, 그룹은 트리로 표현한다.
- 트리의 루트가 그룹의 대표 역할을 한다. 즉, 루트 노드의 번호가 그룹의 식별자이다.

### 트리 구조 표현

트리 구조를 표현하기 위해서 각 정점의 부모를 기록하는 배열 `p`를 사용한다.

- `p[x]`는 정점 `x`의 부모의 번호이다.
- 처음에는 배열의 각 원소를 `-1`로 초기화했는데 이는 각각의 원소가 모두 루트라는 의미이다.
  - Union by rank를 적용할 때, 루트인 경우, `p` 배열에 `-1`이 아닌 음수 값을 저장할 수 있고 절댓값은 랭크 값을 의미한다.
  - 중요한 것은, `p[x]`가 음수이면 `x`가 루트는 의미이다.

```cpp title="union-find.cpp"
vector<int> p(1000005, -1);
```

### find 연산 구현

`find(x)`는 정점 x가 속한 그룹의 루트 번호를 반환하는 함수이다. 두 정점 a, b가 있을 때 `find(a)`와 `find(b)`가 같다면, 두 정점은 같은 그룹이라고 판단할 수 있다.

```cpp title="union-find.cpp"
int find(int x) {
  if (p[x] < 0) return x; // x가 루트이면 그대로 반환.
  return find(p[x]); // x가 루트가 아니라면, 재귀적으로 루트를 탐색.
}
```

### union 연산 구현

`uni(a, b)`는 정점 a가 속한 그룹과 정점 b가 속한 그룹을 하나로 합치는 함수이다.
C언어에서 공용체를 위해 union이라는 키워드가 사용되므로, 함수 이름을 union으로 지을 수 없다.

```cpp title="union-find.cpp"
bool uni(int a, int b) {
  a = find(a);
  b = find(b);

  // 이미 같은 그룹이면 false 반환.
  if (a == b) return false;

  // b가 속한 그룹을, a가 속한 그룹의 자식으로 두어서 합침.
  p[b] = a;
  return true;
}
```

### 시간복잡도

결국 find 함수가 전체 시간복잡도를 결정한다. Linked List 같은 **일자 형태의 트리가 생성**되면 **find 함수의 시간복잡도가 O(N)이 된다.**

### 최적화 - Union by rank

트리의 **높이를 낮추어야** 빠르게 연산할 수 있다.

**높이가 높은 트리의 자식으로 높이가 낮은 트리를 두어서 합치는 게,** 높이가 낮은 트리의 자식으로 높이가 높은 트리를 두어서 합치는 것보다 **전체적인 높이가 낮아진다.**

따라서 **union 연산에서 높이가 높은 트리의 자식으로 높이가 낮은 트리를 두어서 합치는 방식을 사용해 최적화**를 한다.

트리의 높이가 랭크이고, 랭크를 비교해서 높은 트리의 자식으로 낮은 트리를 두면 된다.

경로 압축이 추가되면, find 연산할 때 트리의 구조가 바뀌게 되어서 트리의 높이와 랭크가 다른 값을 갖게 될 수 있다.

```cpp title="union-find.cpp"
// p[x]가 음수인 경우, x는 루트이다.
// x가 루트일 때, p[x]의 절댓값으로 트리의 높이(랭크)를 표현할 것이다.
// 예를 들어서 p[3] = -6이면,
// 3번 정점이 루트이고, 트리의 높이(랭크)는 6이라는 의미이다.

bool uni(int a, int b) {
  a = find(a);
  b = find(b);
  if (a == b) return false;

  // 항상 (a의 랭크 >= b의 랭크)가 성립하게 swap.
  // b를 a의 자식으로 만들어서 합칠것이다.
  if (-p[a] < -p[b]) swap(a, b);
  // 높이(랭크)가 같은 트리를 합치는 경우, 루트가 될 a의 랭크를 1증가 시킨다.
  if (-p[a] == -p[b]) p[a]--;
  p[b] = a;
  return true;
}
```

### 최적화 - 경로 압축

**find 연산**을 수행할 때, **재귀적으로 거쳐 간 원소들을 모두 루트의 자식으로 만들어서 트리의 높이를 낮추는 최적화 방법**이다.

```cpp title="union-find.cpp"
int find(int x) {
  if (p[x] < 0) return x;
  // 루트 값 find(p[x])로, p[x]를 업데이트한다.
  return p[x] = find(p[x]);
}
```

### 최적화에 따른 시간복잡도

| 최적화                    | 시간복잡도                        |
| ------------------------- | --------------------------------- |
| Union by rank             | O(lgN)                            |
| 경로 압축                 | Amortized O(lgN)                  |
| Union by rank + 경로 압축 | Amortized O(α(N)), 거의 상수 시간 |

- Union by rank, 경로 압축 중 하나만 적용해도 union, find 연산의 속도가 빠르다.
- 둘 다 적용하면 사실상 상수 시간에 동작하는 union, find를 구현할 수 있다.
- Amortized O(lgN)에서 Amortized라는 것은 트리가 일자 형태라면 find 연산에 O(N), 경로 압축이 적용되어 루트의 자식에 대해 find 연산을 하면 O(1), 이런 식으로 다양한 상황이 있지만 전체적으로 합치면 O(lgN)에 가까운 시간복잡도라는 의미이다.

## 실행 시간 테스트

[Baekjoon 1717 집합의 표현](https://www.acmicpc.net/problem/1717) 문제로 실행 시간을 테스트 한 결과는 다음과 같다.

| 최적화                    | 시간복잡도 (ms) |
| ------------------------- | --------------- |
| 안함                      | 1584            |
| Union by rank             | 36              |
| 경로 압축                 | 36              |
| Union by rank + 경로 압축 | 32              |

Union by rank나 경로 압축 중 하나만 적용해도 빠르다.

## 참고

- [바킹독의 실전 알고리즘 부록 D - Union-Find](https://blog.encrypted.gg/1097)
1c:T38e5,
## 이진 탐색

주어진 배열에서 원하는 값을 찾기 위해서 어떻게 해야 할까? 배열의 첫 번째 요소부터 마지막 요소까지 순서대로 순회하면서 원하는 값인지 확인하면 된다. 이렇게 선형 탐색을 수행하면 시간복잡도는 `O(N)`이 된다.

만약 배열이 정렬되어 있다면, **배열의 중앙에 위치한 요소와 찾고자 하는 값을 비교**해 **매번 탐색 범위를 절반으로 줄일 수 있다.** 탐색 범위의 크기가 `N`에서 `1`까지 계속해서 절반으로 줄어들기 때문에 시간복잡도는 `O(lgN)`이다. 이것이 **이진 탐색**이다.

### 이진 탐색 아이디어

찾으려는 target이 `6`이고, 다음과 같은 정렬된 배열 array가 있다고 하자.

|       |     |     |     |     |     |     |     |     |     |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| value | 1   | 3   | 3   | 3   | 5   | 5   | 7   | 7   | 9   |

탐색 범위를 표현하기 위해 두 개의 커서 `st`와 `en`이 필요하다. `st`는 탐색 범위의 시작 요소를 가리키고, `en`은 끝 요소를 가리킨다. 탐색 범위를 `[st, en]`으로 표현할 수 있다.

초기에는 탐색 범위가 `[0, 8]`인 상황이다.

탐색 범위의 중앙에 위치한 요소는 `array[4]`이고, `array[4]`의 값 `5`는 target 값 `6`보다 작다. array는 정렬되어 있으므로 `array[4]` 뿐만 아니라 `array[0]`부터 `array[3]`도 target보다 작고, 이들을 한 번에 탐색 범위에서 제거해도 된다. 그래서 `st`를 `5`로 변경해 탐색 범위를 `[5, 8]`로 줄인다. **탐색 범위의 중앙에 위치한 요소와 찾고자 하는 값의 비교 한 번으로 탐색 범위를 절반으로 줄였다.**

이제 탐색 범위가 `[5, 8]`인 상황이다.

탐색 범위의 중앙에 위치한 요소는 `array[6]`이고, `array[6]`의 값 `7`은 target 값 `6`보다 크다. array는 정렬되어 있으므로 `array[6]` 뿐만 아니라 `array[7]`, `array[8]`도 target보다 크고, 이들을 한 번에 탐색 범위에서 제거해도 된다. 그래서 `en`을 `5`로 변경해 탐색 범위를 `[5, 5]`로 줄인다.

이제 탐색 범위가 `[5, 5]`인 상황이다.

탐색 범위의 중앙에 위치한 요소는 `array[5]`이고, `array[5]`의 값 `5`는 target 값 `6`보다 작다. array는 정렬되어 있기 때문에, 인덱스 `5` 이하의 요소들은 모두 target보다 작고 이들을 탐색 범위에서 제거하기 위해 `st`를 `6`으로 변경한다. 탐색 범위가 `[6, 5]`가 되었다.

target인 `6`을 array에서 못 찾았지만, `st`가 `6`, `en`이 `5`가 되어 **더 이상 탐색할 범위가 없으므로 종료**한다.

이 예시는 target이 array에 없는 경우지만, target이 array에 있는 경우에는 탐색 범위의 중앙값이 target과 같을 때 반복을 종료하게 된다.

### 이진 탐색 구현 코드

```js title="binary-search.js"
// array에서 찾은 target의 idx를 반환한다. 없다면 -1을 반환한다.
function binarySearch(array, target) {
  // 탐색 범위를 의미하는 st, en 커서
  // 즉 탐색범위는 array[st], ..., array[en] 이다.
  let st = 0;
  let en = array.length - 1;
  // (찾은) target의 인덱스. -1이면 없다는 의미이다.
  let idx = -1;

  // st와 en이 같아서 탐색 범위의 길이가 1이어도 탐색을 진행한다.
  // st > en이 되어서 탐색 범위가 사라지면 반복문 종료.
  while (st <= en) {
    const md = Math.trunc((st + en) / 2);
    if (array[md] < target) {
      // array[md] < target이므로,
      // (array는 정렬되어 있으니까)
      // array[st], ..., array[md] 값은 모두 target보다 작다.
      // st를 md+1로 업데이트해서,
      // array[st], ..., array[md] 들을 탐색 구간에서 제외한다.
      st = md + 1;
    } else if (array[md] > target) {
      // array[md] > target이므로,
      // (array는 정렬되어 있으니까)
      // array[md], ..., array[en] 값은 모두 target보다 크다.
      // en = md-1로 업데이트해서,
      // array[md], ..., array[en] 들을 탐색 구간에서 제외한다.
      en = md - 1;
    } else {
      // target을 찾은 경우.
      idx = md;
      break;
    }
  }
  return idx;
}
```

## lower bound, upper bound

정렬된 array 배열에 target 값을 삽입할 때,

- 정렬 순서가 깨지지 않는 가장 왼쪽 위치(인덱스)를 lower bound
- 정렬 순서가 깨지지 않는 가장 오른쪽 위치(인덱스)를 upper bound

라고 한다.

|       |     |     |     |     |     |     |       |     |       |     |     |
| ----- | --- | --- | --- | --- | --- | --- | ----- | --- | ----- | --- | --- |
| index | 0   | 1   | 2   | 3   | 4   | 5   | **6** | 7   | **8** | 9   | 10  |
| value | 1   | 3   | 3   | 3   | 4   | 4   | 5     | 5   | 7     | 7   | 9   |

위의 정렬된 배열에 `5`를 삽일 할 때, lower bound는 `6`, upper bound는 `8`이다.

`array[6]`에 `5`를 삽입해도 아래 배열처럼 정렬 순서가 깨지지 않는다. (기존의 `array[6]`, ..., `array[10]` 요소들을 한 칸씩 뒤로 옮기고, `array[6]`에 `5`를 넣어야 한다.)

|       |     |     |     |     |     |     |     |     |     |     |     |     |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  |
| value | 1   | 3   | 3   | 3   | 4   | 4   | 5   | 5   | 5   | 7   | 7   | 9   |

만약 `array[5]`에 `5`를 삽입했다면, 정렬 순서가 깨진다. 그래서 `5`는 lower bound가 아니고 `6`은 lower bound이다.

`array[8]`에 `5`를 삽입해도 아래 배열처럼 정렬 순서가 깨지지 않는다.

|       |     |     |     |     |     |     |     |     |     |     |     |     |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| index | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  |
| value | 1   | 3   | 3   | 3   | 4   | 4   | 5   | 5   | 5   | 7   | 7   | 9   |

만약 `array[9]`에 `5`를 삽입했다면, 정렬 순서가 깨진다. 그래서 `9`는 upper bound가 아니고 `8`은 upper bound이다.

### lower bound, upper bound 아이디어

lower bound와 upper bound를 구현할 때도 선형 탐색을 이용할 수 있다. 단지, 시간복잡도가 `O(N)`이 될 뿐이다. 하지만 lower bound와 upper bound를 구해야 하는 상황에서 배열은 이미 정렬된 상태이므로, 이진 탐색의 아이디어를 사용해서 시간복잡도를 `O(lgN)`으로 만들 수 있다.

정렬된 array에서 target의 **lower bound를 찾는 과정**은 **array에서 target 이상의 요소 중 가장 작은 인덱스를 찾는 과정**이다.

길이가 `11`인 정렬된 array에서 `5`(target)의 lower bound를 구하는 과정은 다음과 같다.

|       |     |     |     |     |     |     |       |     |     |     |     |     |
| ----- | --- | --- | --- | --- | --- | --- | ----- | --- | --- | --- | --- | --- |
| index | 0   | 1   | 2   | 3   | 4   | 5   | **6** | 7   | 8   | 9   | 10  | 11  |
| value | 1   | 3   | 3   | 3   | 4   | 4   | 5     | 5   | 7   | 7   | 9   |     |

탐색 범위를 표현하기 위해 시작점을 가리키는 `st`, 끝점을 가리키는 `en` 커서가 필요하다.

초기 탐색 범위는 `[0, 11]`인 상황이다. **마지막 요소 뒤 인덱스도 lower bound가 될 수 있기 때문에** 인덱스 `11`도 범위에 포함한다.

탐색 범위의 중앙에 위치한 `array[5]`의 값 `4`는 target 값 `5`보다 작다. array는 정렬되어 있기 때문에 `array[5]`와 왼쪽에 위치한 요소들은 모두 target보다 작다. target보다 작으면 lower bound가 될 수 없기 때문에 인덱스 `5` 이하를 탐색 범위에서 제거한다. `st`를 `6`으로 변경해 탐색 범위를 `[6, 11]`로 줄인다.

이제 탐색 범위가 `[6, 11]`인 상황이다.

탐색 범위의 중앙에 위치한 `array[8]`의 값 `7`은 target 값 `5`보다 크다. array는 정렬되어 있기 때문에 `array[8]`와 오른쪽에 위치한 요소들은 모두 target 초과이다. target 초과이면서 인덱스가 더 작은 `array[8]`이 있어서, 인덱스가 `9` 이상인 요소들은 lower bound가 될 수 없다. 인덱스 `9` 이상을 탐색 범위에서 제거한다. `en`을 `8`로 변경해 탐색 범위를 `[6, 8]`로 줄인다.

이제 탐색 범위가 `[6, 8]`인 상황이다.

탐색 범위 중앙에 위치한 `array[7]`의 값 `5`는 target 값 `5`와 같다. array는 정렬되어 있기 때문에 `array[7]`과 오른쪽에 위치한 요소들은 모두 target 이상이다. target 이상이면서 인덱스가 더 작은 `array[7]`이 있어서, 인덱스가 `8` 이상인 요소들은 lower bound가 될 수 없다. 인덱스 `8` 이상을 탐색 범위에서 제거한다. `en`을 `7`로 변경해 탐색 범위를 `[6, 7]`로 줄인다.

이제 탐색 범위가 `[6, 7]`인 상황이다.

탐색 범위의 중앙에 위치한 `array[6]`의 값 `5`는 target 값 `5`와 같다. array는 정렬되어 있기 때문에 `array[6]`과 오른쪽에 위치한 요소들은 모두 target 이상이다. target 이상이면서 인덱스가 더 작은 `array[6]`이 있어서, 인덱스가 `7` 이상인 요소들은 lower bound가 될 수 없다. 인덱스 `7` 이상을 탐색 범위에서 제거한다. `en`을 `6`으로 변경해 탐색 범위를 `[6, 6]`으로 줄인다.

이제 탐색 범위가 `[6, 6]`인 상황이다. 이는 인덱스 `6`을 의미하고, 이 값이 정렬된 array에서 `5`의 lower bound가 된다. `array[6]`이 `5` 이상의 값 중 가장 작은 인덱스를 갖는 요소이다.

탐색 범위 `[st, en]`의 크기가 `1`이 될 때까지 중앙값과 target을 비교해 범위를 줄이면 lower bound를 찾을 수 있다.

- **중앙값 \>\= target** 일 때는 중앙값의 오른쪽에 위치한 요소들은 인덱스가 중앙값보다 커서 lower bound가 될 수 없다. 중앙값을 lower bound가 될 수 있는 마지노선으로 간주하고, `[st, en]` -> `[st, md]`로 탐색 범위를 줄인다.
- **중앙값 \< target** 일 때는 중앙값과 왼쪽에 위치한 요소들이 target보다 작아서 lower bound가 될 수 없다. `[st, en]` -> `[md+1, en]`으로 탐색 범위를 줄인다.

정렬된 array에서 target의 **upper bound를 찾는 과정**은 **array에서 target 초과의 요소 중 가장 작은 인덱스를 찾는 과정**이다.

lower bound를 찾는 과정과 비슷하게 탐색 범위 `[st, en]`의 크기가 `1`이 될 때까지 중앙값과 target을 비교해 범위를 줄이면 upper bound를 찾을 수 있다.

- **중앙값 \> target** 일 때는 중앙값의 오른쪽에 위치한 요소들은 인덱스가 중앙값보다 커서 upper bound가 될 수 없다. 중앙값을 upper bound가 될 수 있는 마지노선으로 간주하고, `[st, en]` -> `[st, md]`로 탐색 범위를 줄인다.
- **중앙값 \<\= target** 일 때는 중앙값과 왼쪽에 위치한 요소들이 target 이하라서 upper bound가 될 수 없다. `[st, en]` -> `[md+1, en]`으로 탐색 범위를 줄인다.

### lower bound 구현 코드

```js title="lower-bound.js"
function lowerBound(array, target) {
  // 탐색 범위 [st, en].
  let st = 0;

  // 마지막 요소 뒤 인덱스도 lower bound가 될 수 있는 후보.
  let en = array.length;

  while (st < en) {
    // 탐색 범위의 길이가 1이 될 때까지 반복.
    const md = Math.trunc((st + en) / 2);
    if (array[md] >= target) {
      // array[md]의 오른쪽에 위치한 요소들은
      // (즉, array[md+1], ..., array[en])
      // target 이상이지만,
      // md보다 인덱스가 크기 때문에 lower bound가 될 수 없다.
      // array[md] 오른쪽에 위치한 요소들을 탐색 범위에서 제거한다.
      // [st, en] -> [st, md]
      en = md;
    } else {
      // array[md] < target
      // array[md]와 array[md] 왼쪽에 위치한 요소들은
      // (즉, array[st], ..., array[md-1])
      // target 미만이라서 lower bound가 아니다.
      // array[md]와 array[md] 왼쪽에 위치한 요소들을
      // 탐색 범위에서 제거한다.
      // [st, en] -> [md+1, en]
      st = md + 1;
    }
  }
  return st;
}
```

### upper bound 구현 코드

```js title="upper-bound.js"
function upperBound(array, target) {
  let st = 0;

  // 마지막 요소 뒤 인덱스도 upper bound가 될 수 있는 후보.
  let en = array.length;
  while (st < en) {
    const md = Math.trunc((st + en) / 2);
    if (array[md] > target) {
      // array[md]의 오른쪽에 위치한 요소들은
      // (즉, array[md+1], ..., array[en])
      // target 초과이지만,
      // md보다 인덱스가 크기 때문에 upper bound가 될 수 없다.
      // array[md] 오른쪽에 위치한 요소들을 탐색 범위에서 제거한다.
      // [st, en] -> [st, md]
      en = md;
    } else {
      // array[md] <= target
      // array[md]와 array[md] 왼쪽에 위치한 요소들은
      // (즉, array[st], ..., array[md-1])
      // target 이하라서 upper bound가 아니다.
      // array[md]와 array[md] 왼쪽에 위치한 요소들을
      // 탐색 범위에서 제거한다.
      // [st, en] -> [md+1, en]
      st = md + 1;
    }
  }
  return st;
}
```

### 이진 탐색 구현 코드와 lower bound, upper bound 구현 코드 비교

이진 탐색 구현 코드에서는 탐색 범위의 크기가 `1`일 때도 비교를 수행하지만, lower bound와 upper bound 구현 코드에서는 탐색 범위의 크기가 `1`이 되는 순간 비교를 중단한다.

이진 탐색을 수행할 때 array에 target이 있을 수도 있고, 없을 수도 있다. 그래서 탐색 범위의 크기가 `0`이 될 때까지 비교를 수행해 봐야 한다.

하지만, lower bound와 upper bound에 해당하는 위치는 탐색 범위에 무조건 존재한다. 그래서 탐색 범위의 크기가 `1`이 되는 순간 비교를 중단하고, 그 위치를 lower bound, upper bound라고 판단할 수 있다.

### lower bound, upper bound 활용

lower bound, upper bound를 활용해 **정렬된 배열에서 특정 요소의 개수를 세거나**, lower bound를 이용해 **정렬된 배열에서 등수 계산** 등을 할 수 있다.

## 참고

- [바킹독의 실전 알고리즘 0x13강-이분탐색](https://blog.encrypted.gg/985)
1d:T412f,
## 만들고 싶은 것

글 내부의 제목(h2, h3)을 활용해 간단하게 **글의 목차를 표시**하고 싶었다. 또, **사용자가 보고있는 영역의 제목을 highlight**해서 현재 어떤 부분을 읽고 있는지 쉽게 알려주고 싶었다. 이러한 TOC 컴포넌트는 라이브러리의 공식문서, 블로그 등에서 널리 사용되는 컴포넌트이기도 하다.

![toc-example](/images/posts/2024/toc/react-doc-toc-example.png)

위의 그림은 React 공식 문서에서 사용하는 TOC인데, 위와 같은 컴포넌트를 개발하고 싶었다.

## 글 내부의 제목을 추출해서 표시하기

한 번에 모든 기능을 구현하기 어려울 것 같아서, 먼저 글 내부의 제목을 추출해서 표시하는 기능부터 구현하기로 했다.

먼저 생각한 방법은 **웹 브라우저에서 `document.querySelectorAll("h2,h3")`를 호출**해 제목을 추출하는 방법이다. 사용하는 데 문제 없는 방식이긴 하지만 브라우저에서 컴포넌트가 mount 되고 나서야 목차를 표시할 수 있다. ~~(물론 금방 표시된다.)~~

"next 애플리케이션을 build 할 때 서버가 글 데이터를 다 가지고 있는데, 굳이 브라우저에서 제목을 추출해야 하나? 서버에서도 충분히 할 수 있을거 같은데"라는 생각이 들었고, 서버에서 제목을 추출하는 방법을 찾던 중 `@vcarl/remark-headings`라는 remark plugin을 발견하게 되었다.

`@vcarl/remark-headings` plugin은 markdown에서 `#`, `##` 등으로 시작하는 **제목을 추출해주는 plugin**이고, **서버에서 파일형태로 저장된 글들을 읽고나서** 이 plugin을 이용해 글 안의 제목 정보를 추출하도록 만들었다. 추출한 제목 정보로 목차를 화면에 표시하면 된다.

## 목차 아이템을 클릭했을 때, 해당 영역으로 스크롤하는 기능 구현

다음으로 구현해야 할 기능은 **목차 아이템을 클릭했을 때, 해당 목차 아이템을 제목으로 하는 영역이 화면에 나타나도록 스크롤**하는 기능이다.

`element.scrollIntoView()` 메서드를 사용할 수도 있지만, 이를 위해서는 글 내부의 모든 제목을 ref로 접근할 수 있도록 별도의 코드를 작성해야 한다.

실제로 구현할 때는 **URI fragment**를 사용했다. `https://react.dev/learn/your-first-component#components-ui-building-blocks` 에서 `#components-ui-building-blocks` 부분을 `URI fragment`라고 한다. `#`으로 시작하는 문자열이고 리소스의 특정 부분을 식별하는데 사용한다. 리소스의 특정 부분이라함은 '문서의 특정 section'이나 '영상의 특정 position'이 될 수 있다. fragment는 서버에 URI를 요청할 때 전송하지 않고, 리소스를 불러온 후 클라이언트에서 처리한다는 특징이 있다. 또, HTML 문서에서 element의 id가 fragment가 될 수 있고, **fragment가 포함된 URI를 웹 브라우저 주소창에 입력하면 브라우저가 해당 element로 스크롤한다.**

**글을 HTML로 변환할 때 h2, h3 태그에 id를 부여**하고, TOC 컴포넌트에서는 **해당 id fragment를 가리키는 link로 목차 아이템을 만들면**, 브라우저의 기본 동작에 의해 **목차 아이템(링크)을 클릭했을 때 해당 영역으로 이동하게 된다.**

markdown 형태의 글을 HTML로 변환하면서 생성될 h2, h3 태그에 id를 값을 기반으로 자동으로 부여하기 위해서 `remark-heading-id` plugin을 활용했다.

## 중간 정리

지금까지의 아이디어를 정리하면 다음과 같다.

- markdown 또는 mdx 형식의 **글을 HTML로 변환할 때**, `remark-heading-id` plugin을 사용해 heading의 값을 기반으로 **id를 만들어 생성될 h2, h3 태그에 주입**한다.
- markdown 또는 mdx 형식의 글에 `@vcarl/remark-headings plugin`을 적용해 **글 내부의 제목 정보를 모두 추출**한다.
- **추출한 글 내부의 제목 정보를 순회하면서 리스트 형식으로 목차 아이템을 표시**한다. **목차 아이템은 `#{id}`를 href로 하는 링크**이다.

추가로, **스크롤이 부드럽게** 되길 바란다면 스크롤 컨테이너에 `scroll-behavior: smooth;` CSS를 적용하면 된다.

![toc-implement](/images/posts/2024/toc/toc-implement.webp)

구현 결과는 위와 같다. 목차 아이템을 클릭했을 때 해당 영역으로 잘 이동한다.

## 사용자가 보고 있는 영역의 제목을 highlight 하기

마지막으로 구현하고 싶었던 기능은 사용자가 보고 있는 영역의 제목을 highlight 하는 기능이다.

화면에 표시될 **h2, h3 태그의 가시성 변화를 감지**하면 될 것 같아 **Intersection Observer**를 이용해 구현하기로 했다.

### Intersection Observer로 h2, h3를 관찰하는 방법을 이용한 구현

```tsx title="post-article-toc-sidebar.tsx" showLineNumbers {16-18,21-23,25-48,50-53,55-57,72}
"use client";

import { useEffect, useState } from "react";
import PostArticleTOCItem from "./post-article-toc-item";
import HorizontalSeparator from "../../separator/horizontal-separator";

type Props = {
  headings: {
    type: "h2" | "h3";
    text: string;
    id: string;
  }[];
};

export default function PostArticleTOCSidebar({ headings }: Props) {
  const [activeHeadingIdSet, setActiveHeadingIdSet] = useState<Set<string>>(
    () => new Set(),
  );

  useEffect(() => {
    const headingElements = headings.map((heading) =>
      document.querySelector(`#article-content #${heading.id}`),
    );

    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          const id = entry.target.getAttribute("id");
          if (!id) continue;
          if (entry.isIntersecting) {
            setActiveHeadingIdSet((prev) => {
              const nxt = new Set(prev);
              nxt.add(id);
              return nxt;
            });
          } else {
            setActiveHeadingIdSet((prev) => {
              const nxt = new Set(prev);
              nxt.delete(id);
              return nxt;
            });
          }
        }
      },
      {
        rootMargin: "-64px 0px 0px 0px", // sticky header 영역 제외
      },
    );

    for (const headingElement of headingElements) {
      if (!headingElement) continue;
      observer.observe(headingElement);
    }

    return () => {
      observer.disconnect();
    };
  }, [headings]);

  return (
    <section className="max-h-full rounded-md border border-zinc-300 dark:border-zinc-700 p-3 flex flex-col gap-3">
      <h2 className="text-lg shrink-0">목차</h2>
      <HorizontalSeparator />
      <nav className="flex-grow overflow-auto">
        <ul className="flex flex-col gap-1">
          {headings.map((item) => (
            <PostArticleTOCItem
              key={item.id}
              type={item.type}
              link={`#${item.id}`}
              text={item.text}
              isActive={activeHeadingIdSet.has(item.id)}
            />
          ))}
        </ul>
      </nav>
    </section>
  );
}
```

Intersection Observer 같은 웹 브라우저가 제공하는 API를 사용할 것이므로, useEffect를 사용했다.

**16-18번째 줄**에서 현재 사용자가 보고 있는 h2, h3 태그의 id들을 set으로 관리하는 상태, `activeHeadingIdSet`을 정의했다.

**21-23번째 줄**에서 (Intersection Observer에 등록하기 위해) querySelector로 `heading.id`를 id 값으로 갖는 h2, h3 element들을 모두 찾는다. (처음에는 querySelectorAll로 h2, h3 태그를 모두 찾았는데, 추후 IntersectionObserver가 어느 순간 동작하지 않는 이슈가 발생했다. ~~왜 그런지 모르겠네 ㅜㅜ~~)

**25-48번째 줄**에서 **callback 함수**와 **options**을 인자로 넘기면서 Intersection Observer 인스턴스를 생성한다.

options에서는 관찰 영역을 설정할 수 있고, 기본적으로는 viewport가 관찰 영역이 된다. **46번째 줄**에서 **rootMargin**을 설정했는데, 관찰 영역의 margin을 설정하는 옵션이다. header가 계속 viewport에 표시되므로 header 영역을 관찰 영역에서 제외하려고 설정했다.

callback 함수는 관찰 대상의 가시성에 변경사항이 있을 때 호출된다. callback의 첫 번째 인자로, **가시성에 변경사항이 있는 관찰 대상들만 요소로 하는 배열**이 들어온다.

**27번째 줄**에서 가시성에 변화가 있는 모든 element를 순회하면서, 해당 element의 id 속성을 조회하고(**28-29번째 줄**), viewport에 들어온 element의 경우(`isIntersecting`이 `true`인 경우, **30번째 줄**)엔 `activeHeadingIdSet`에 추가하고, viewport에서 나간 element의 경우(**36번째 줄**) `activeHeadingIdSet`에서 제거한다. **즉 h2, h3가 viewport에 들어오면 `activeHeadingIdSet`에 추가하고, h2, h3가 viewport에서 나가게 되면 `activeHeadingIdSet`에서 제거했다.**

**50-53번째 줄**에서 Intersection Observer 인스턴스에 앞서 찾은 h2, h3 element들을 모두 관찰 대상으로 등록한다.

**55-57번째 줄**의 clean up 함수에서 등록한 관찰 대상을 모두 해제한다.

**72번째 줄**에서는 현재 viewport에 들어온 h2, h3의 id들을 담고 있는 상태, `activeHeadingIdSet`을 활용해 해당 목차 아이템의 활성화 상태를 결정했다.

![observing-headings](/images/posts/2024/toc/toc-highlight-observing-headings-1.webp)

구현 결과 잘 동작하는 것처럼 보인다. (여러개의 h2, h3가 동시에 viewport에 들어오면 모두 highlight 되도록 구현했다.)

### 문제점

![observing-headings-bugs](/images/posts/2024/toc/toc-highlight-observing-headings-2.webp)

위 그림에서 "결과" -> "클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결" **영역**으로 스크롤을 옮겼음에도, TOC 컴포넌트에서 "클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결" 목차 아이템이 highlight 되지 않았다.

원인은 생각보다 간단한데, "클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결" 제목이 viewport에 나타나지 않았기 때문이다. 위에서 구현할 때 Intersection Observer로 h2, h3 제목을 관찰했으므로 제목이 viewport에 나타나지 않으면 TOC 컴포넌트는 반응하지 않는다.

### 해결

**제목을 관찰하는 게 아니라 제목을 포함한 영역을 관찰해야 겠다**는 생각이 들었고, h2, h3를 div나 section 같은 태그로 감싸고 그 태그를 관찰하도록 만들면 될 것 같았다.

다행히 `remark-sectionize` plugin을 이용하면 markdown/mdx에서 HTML로 글을 변환하면서 h2, h3를 감싸는 section을 쉽게 주입할 수 있었다.

```md
## heading2

This is heading2 content

### heading3 - 1

This is heading3 - 1 content

### heading3 - 2

This is heading3 - 2 content
```

위의 markdown은 HTML로 변환하면

```html
<h2>heading2</h2>
<p>This is heading2 content</p>
<h3>heading3 - 1</h3>
<p>This is heading3 - 1 content</p>
<h3>heading3 - 2</h3>
<p>This is heading3 - 2 content</p>
```

원래는 위의 형태로 변환되는데, `remark-sectionize` plugin을 사용하면

```html
<section>
  <h2>heading2</h2>
  <p>This is heading2 content</p>
  <section>
    <h3>heading3 - 1</h3>
    <p>This is heading3 - 1 content</p>
  </section>
  <section>
    <h3>heading3 - 2</h3>
    <p>This is heading3 - 2 content</p>
  </section>
</section>
```

위의 형태로 변환된다. h2, h3를 감싸는 section 태그가 생성되었다.

그리고 이젠 h2, h3 대신 section을 관찰할 것이다. 다음과 같이 코드를 수정했다.

```tsx title="post-article-toc-sidebar.tsx" showLineNumbers {21-23, 28-29,52-54}
"use client";

import { useEffect, useState } from "react";
import PostArticleTOCItem from "./post-article-toc-item";
import HorizontalSeparator from "../../separator/horizontal-separator";

type Props = {
  headings: {
    type: "h2" | "h3";
    text: string;
    id: string;
  }[];
};

export default function PostArticleTOCSidebar({ headings }: Props) {
  const [activeHeadingIdSet, setActiveHeadingIdSet] = useState<Set<string>>(
    () => new Set(),
  );

  useEffect(() => {
    const sectionElements = document.querySelectorAll(
      "#article-content section",
    );

    const observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          const heading = entry.target.querySelector("h2,h3");
          if (!heading) continue;
          const id = heading.getAttribute("id");
          if (!id) continue;
          if (entry.isIntersecting) {
            setActiveHeadingIdSet((prev) => {
              const nxt = new Set(prev);
              nxt.add(id);
              return nxt;
            });
          } else {
            setActiveHeadingIdSet((prev) => {
              const nxt = new Set(prev);
              nxt.delete(id);
              return nxt;
            });
          }
        }
      },
      {
        rootMargin: "-64px 0px 0px 0px", // sticky header 영역 제외
      },
    );

    sectionElements.forEach((sectionElement) =>
      observer.observe(sectionElement),
    );

    return () => {
      observer.disconnect();
    };
  }, []);

  return (
    <section className="max-h-full rounded-md border border-zinc-300 dark:border-zinc-700 p-3 flex flex-col gap-3">
      <h2 className="text-lg shrink-0">목차</h2>
      <HorizontalSeparator />
      <nav className="flex-grow overflow-auto">
        <ul className="flex flex-col gap-1">
          {headings.map((item) => (
            <PostArticleTOCItem
              key={item.id}
              type={item.type}
              link={`#${item.id}`}
              text={item.text}
              isActive={activeHeadingIdSet.has(item.id)}
            />
          ))}
        </ul>
      </nav>
    </section>
  );
}
```

`headings` prop이 가지고 있는 id 값을 이용해 id 속성을 갖는 h2, h3를 조회하는 대신, **21-23번째 줄**에서 section들을 조회했다.

그리고 **52-54번째 줄**에서 이 section들을 Intersection Observer의 관찰 대상으로 등록했다.

callback 내부에서는 `entry`가 더이상 h2, h3 element가 아니라 section element이기 때문에 자식 h2, h3 element를 찾는 과정이 추가되었다. (**28-29번째 줄**)

![observing-sections](/images/posts/2024/toc/toc-highlight-observing-section.webp)

이제 "결과" -> "클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결" 영역으로 스크롤을 옮기면, 비록 "클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결"이라는 **제목이 viewport에 없어도, 그 제목을 포함하는 영역이 viewport에 나타나면** TOC에서 "클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결" **목차 아이템을 highlight 한다.**

## 정리

개인 웹 사이트를 개발하면서 글 관련 기능으로 TOC 기능을 꼭 구현하고 싶었다. 글 전체의 흐름을 알려주고 글 내부의 여기 저기를 편하게 옮겨 다닐 수 있어서 유용할 것 같았다.

쉽게 만들 수 있을 것 같았는데 구현하다보니 신경써야 할 부분이 많았다.

서버에서 글들을 읽어들이고 HTML로 변환할 때, remark 플러그인을 활용해 h2, h3 관련 데이터를 미리 추출하고 이를 이용해 TOC 컴포넌트의 목차 아이템들을 표시했다.

또, 글들을 HTML로 변환할 때 h2, h3 태그에 id 속성을 주입하고(값을 기반으로 자동 생성, remark plugin 활용) 목차 아이템을 해당 h2, h3를 가리키는 링크로 만들어(URI fragment 활용) 목차 아이템을 클릭했을 때 해당 영역으로 스크롤하는 기능을 구현했다.

사용자가 현재 보고 있는 부분의 목차 아이템을 highlight 하는 기능을 만들기 위해서 viewport의 h2, h3의 가시성을 관찰하는 Intersection Observer를 활용하는 방법을 사용했었다. 잘 동작하는 것 같았지만 h2, h3의 가시성만 관찰했기 때문에 viewport에 h2, h3가 없는 경우 사용자가 보고 있는 영역의 제목을 highlight 하지 못했다.

글을 HTML로 변환할 때 h2, h3를 감싸는 section을 주입했고, Intersection Observer가 h2, h3 대신 이 section을 관찰하도록 구현해서 비록 viewport에 h2, h3 태그가 없더라도 사용자가 보고 있는 영역을 판단할 수 있게 고쳤다.
1e:T2bfb,
## 문제

회사에서 React 컴포넌트 라이브러리를 개발하는 중인데, 기존에는 빌드 도구로 Rollup을 사용하고 있었다.

팀에서는 `yarn link`를 활용해 개발 중인 라이브러리의 심볼릭 링크를 만들고, (local의) 테스트용 애플리케이션에서 라이브러리를 링크해서 개발하고 있었다. 코드를 변경할 때마다 라이브러리가 빌드되고, 빌드된 결과물이 테스트용 애플리케이션에 반영되어 화면에 변경사항이 표시되는 방식이다.

그런데, **빌드 시간이 1분 넘게 걸렸기 때문에, 코드를 변경하고 변경사항을 눈으로 확인하는 데 너무 오래 걸렸다.**

![rollup build 속도](/images/posts/2024/lib-configuration-based-on-vite/rollup-build-time.png)

기존에 사용하던 Rollup 버전이 너무 오래 되었고(기존 버전: `2`, 24.06.12 기준 최신 버전: `4`), Rollup 설정 파일도 2년 전에 퇴사 하신분의 commit을 끝으로 관리되지 않았다.

그래서 최근 빠른 속도로 각광 받고 있는 Vite를 도입하면서 빌드 속도를 개선하기로 했다.

## 사용한 Vite 플러그인

### @vitejs/plugin-react

Vite 프로젝트에서 React를 사용할 수 있게 만드는 플러그인, Babel 기반.

### vite-plugin-dts

lib mode로 Vite를 사용할 때, declaration file(`*.d.ts`)을 생성해주는 플러그인.

개발 중인 라이브러리가 TypeScript로 작성한 라이브러리이기도 하고, 클라이언트 코드에서 타입 추론이 가능하도록 이 플러그인을 사용했다.

### vite-tsconfig-paths

`tsconfig.json`에 작성한 `compilerOptions.paths`를 이용해, Vite가 모듈의 위치를 찾도록 도와주는 플러그인.

`vite.config.ts`에 `resolve.alias`를 설정할 필요가 없어진다. (같은 설정을 `tsconfig.json`과 `vite.config.ts`에 해야하는 불편함을 해결해준다.)

### vite-plugin-css-injected-by-js

Vite로 빌드하면, bundle된 js 파일과 css 파일이 생성된다. 이때 생성된 css를 bundle된 js 내부에서 import하도록 만들고 싶어서 이 플러그인을 사용했다. 이렇게 하면, 클라이언트 코드에서 별도로 라이브러리의 css 파일을 import 할 필요가 없다.

## Vite 플러그인 설정하기

**@vitejs/plugin-react** 플러그인을 사용해서 Vite 프로젝트에서 React 코드를 작성할 수 있게 했고, **vite-plugin-dts** 플러그인을 사용해서 lib 모드로 빌드할 때, `*.d.ts` 파일들을 생성하게 만들었다.

**vite-tsconfig-paths** 플러그인을 이용해 path에 대한 alias 설정을 `tsconfig.json` 파일에만 하고 동일한 설정을 vite에서 사용할 수 있게 만들었다.

그리고 클라이언트 코드에서 별도로 css 파일을 import 할 필요없도록 생성된 css를 bundle된 js 파일에 주입하게 **vite-plugin-css-injected-by-js** 플러그인을 사용했다.

```ts title="vite.config.ts"
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import dts from "vite-plugin-dts";
import tsconfigPaths from "vite-tsconfig-paths";
import cssInjectedByJsPlugin from "vite-plugin-css-injected-by-js";

export default defineConfig({
  plugins: [
    react(),
    dts({
      /*
        이 옵션이 false이면
        기본적으로 {outDir}/src에 index.d.ts를 비롯한
        *.d.ts 파일을 생성한다.
        
        이 옵션이 true이면
        {outDir}/dts에 src/index.d.ts를 생성해준다.
        
        즉, dts 디렉터리를 만들고
        그 디렉터리에 src/index.d.ts 파일을 생성한다. 
        
        dts 디렉터리를 만들고 싶지 않다면 굳이 쓸 필요 없다.

        그리고 package.json의 
        "types"에 index.d.ts 파일 경로를 작성하면 된다.
      */
      insertTypesEntry: true,
    }),
    tsconfigPaths(),
    cssInjectedByJsPlugin(),
  ],

  /*
    vite-tsconfig-paths 플러그인을 사용했기 때문에
    이미 tsconfig.json에 설정한 경로 alias 설정을
    vite 설정 파일에 또 설정할 필요가 없다.
  */
  /*
    resolve: {
      alias: [
        {
          find: '@',
          replacement: path.resolve(__dirname, 'src'),
        },
      ],
    },
  */

  // ...
});
```

## Vite 빌드 설정하기

Vite 프로젝트를 라이브러리 형태로 빌드하기 위해서는 `build.lib` 옵션을 설정해야 한다.

**엔트리 파일이 무엇인지, 패키지 이름은 무엇인지, 빌드 결과로 생성될 js 파일의 이름은 어떻게 할 것인지, 어떤 모듈 시스템을 사용해서 빌드할 것인지** 등을 설정할 수 있다.

추가로, 번들에 포함하고 싶지 않은 dependency들은 `build.rollupOptions.external`에 명시할 수 있다.

```ts title="vite.config.ts"
import path from "node:path";
import { defineConfig } from "vite";
// ...

export default defineConfig({
  // ...

  build: {
    // 빌드 결과를 담은 디렉터리.
    // rollup을 쓸 때도 "dist"였기에 그대로 "dist"로 설정
    outDir: "dist",
    lib: {
      // 엔트리 파일
      entry: path.resolve(__dirname, "src/index.ts"),

      // 패키지 이름
      name: "@your-company/your-package",

      // 빌드 결과물 파일 이름
      fileName: (format) => `index.${format}.js`,

      // 어떤 모듈 시스템에 호환되도록 빌드할 것인가
      // rollup을 쓸 때 es, cjs 방식으로 빌드했었기 때문에,
      // 해당 방식을 사용하게 설정
      formats: ["es", "cjs"],
    },
    rollupOptions: {
      // 라이브러리 빌드 결과에 포함하고 싶지 않은 패키지를 명시할 수 있다.
      // 또한, 이 패키지들을 peer dependencies에 명시하면 된다.
      external: [
        "react",
        "react-dom",
        "mobx",
        "mobx-react-lite",
        "@your-company/your-another-package",
      ],
    },
  },
});
```

## 전체 Vite 설정

앞서 언급한 플러그인, 빌드 설정을 정리한 Vite 설정 파일은 다음과 같다. (확실히 기존에 사용하던 rollup 설정 파일보다 간결해졌다.)

```ts title="vite.config.ts"
import path from "node:path";
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import dts from "vite-plugin-dts";
import tsconfigPaths from "vite-tsconfig-paths";
import cssInjectedByJsPlugin from "vite-plugin-css-injected-by-js";

export default defineConfig({
  plugins: [
    react(),
    dts({
      insertTypesEntry: true,
    }),
    tsconfigPaths(),
    cssInjectedByJsPlugin(),
  ],
  build: {
    outDir: "dist",
    lib: {
      entry: path.resolve(__dirname, "src/index.ts"),
      name: "@your-company/your-package",
      fileName: (format) => `index.${format}.js`,
      formats: ["es", "cjs"],
    },
    rollupOptions: {
      external: [
        "react",
        "react-dom",
        "mobx",
        "mobx-react-lite",
        "@your-company/your-another-package",
      ],
    },
  },
});
```

## package.json 파일 설정

라이브러리 개발할 때는 `main`, `module`, `types`, `files` 속성값을 잘 설정하면 된다.

```json
{
  "name": "@your-company/your-package",
  "type": "module",
  "main": "./dist/index.cjs.js",
  "module": "./dist/index.es.js",
  "types": "./dist/dts/src/index.d.ts",
  "files": ["dist"]
}
```

`type`은 `"module"` 또는 `"commonjs"` 값을 가질 수 있는데, `"module"`인 경우, `.js` 파일을 ES 모듈 시스템으로 해석한다는 의미이다.

`main`은 클라이언트 코드에서 라이브러리를 `require()`로 임포트할 때, 진입점이 되는 파일을 설정한다. vite가 `dist/index.cjs.js`로 번들링하도록 설정했기 때문에 `"./dist/index.cjs.js"` 경로를 적어준다.

`module`은 클라이언트 코드에서 라이브러리를 `import`로 임포트할 때, 진입점이 되는 파일을 설정한다. vite가 `dist/index.es.js`로 번들링하도록 설정했기 때문에 `"./dist/index.es.js"` 경로를 적어준다.

`types`에는 타입 선언 파일의 위치를 지정하면 된다. vite-plugin-dts 플러그인이 `dist/dts/src/index.d.ts`를 생성하므로, `"./dist/dts/src/index.d.ts"` 경로를 적어준다.

`files`에는 패키지를 배포할 때 포함할 파일이나 디렉터리를 작성하면 된다. dist 디렉터리를 포함해서 배포할 것이므로, `["dist"]`를 적어준다.

## link를 이용해 개발하기 위한 명령어

`vite build --watch` 명령어를 실행하면, file 변경사항이 발생할 때마다(코드 수정사항이 생길 때마다) 빌드되고, 테스트용 애플리케이션에서는 변경사항을 감지해서 화면을 갱신한다.

## 클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제 해결

환경 설정을 끝마쳤다고 생각했는데, 마지막에 클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제가 발생했다.

기존에는 타입스크립트 설정 파일에서 다음과 같이 **상대경로**를 이용해 경로의 alias를 설정했다.

```json title="tsconfig.json"
{
  "compilerOptions": {
    // ...
    "paths": {
      "@/*": ["./src/*"]
    }
  }
  // ...
}
```

그런데 이 경우, 클라이언트 코드에서 타입 추론이 제대로 되지 않았다.

번들된 결과물을 살펴보니, 생성된 `*.d.ts` 파일에서 `@` alias가 실제 경로로 변환되지 않고 `@` 그대로 남아있었다.

```ts title="dist/../index.d.ts"
import { SomeType } from "@/types";
```

**생성된 `*.d.ts` 파일들에서 `@` alias 대신 실제 경로를 표시하려면, 타입스크립트 설정에서 `compilerOptions.baseUrl` 옵션을 설정하고 `compilerOptions.paths` 옵션에 "`./`으로 시작하지 않는 경로"를 작성하면 된다.**

```json title="tsconfig.json"
{
  "compilerOptions": {
    // ...
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
  // ...
}
```

번들된 결과물을 살펴보면, 생성된 `*.d.ts` 파일에서 `@` alias가 사라지고 실제 경로로 치환되었다.

```ts title="dist/../index.d.ts"
import { SomeType } from "../../../../types";
```

그리고 실제로 클라이언트 코드에서 배포한 라이브러리를 사용할 때, **타입 추론이 잘 되었다.**

## 결과

![vite build 속도](/images/posts/2024/lib-configuration-based-on-vite/vite-build-time.png)

기존에 **1분이 넘던 빌드시간을 10초대로 줄였다.** 팀에서 `yarn link`를 활용해 개발하고 있었는데, 코드를 변경할 때마다 발생하는 빌드에 걸리는 시간이 줄어들어 **팀 개발 생산성이 증가했다**. 팀원들도 속도가 빨라져서 많이 좋아했다.

오래된 버전의 Rollup을 최신 버전의 Vite로 전환하면서, 관리 되지 않던 빌드도구 설정 파일을 최신화 할 수 있었다.

과거 Rollup 버전으로 빌드했을 때 클라이언트 코드에서 타입 추론이 되지 않았었는데, Vite로 전환하면서 타입 추론이 가능하게 설정했다.

빌드도구/번들러 설정은 막연히 어렵다고 생각해왔는데, 이번에 Vite로 성공적으로 전환하면서 자신감을 얻을 수 있었다.
1f:T4772,
회사에서 해시태그 입력 폼을 개발하던 도중, **입력값에 따라서 너비가 늘어나고 줄어드는 input React 컴포넌트**를 개발하게 되었다.

사실, 입력값에 따라 input 같은 요소의 너비를 자동으로 조절해 주는 [`field-sizing` CSS 속성](https://developer.mozilla.org/en-US/docs/Web/CSS/field-sizing)이 있다. 해당 속성에 `content` 값을 주면 원했던 대로 동작한다. 그런데 슬프게도 이 CSS 속성은 **(2024년 기준) 아직 실험 단계**여서 크롬 계열의 브라우저에서만 잘 동작하고, 파이어폭스나 사파리에서 동작하지 않는다. **그래서 직접 구현하기로 결정했다.**

생각보다 간단하지 않았고, 잊어버리기 전에 개발 과정에서 겪었던 시행착오를 기록하고 싶어서 정리했다.

## 요구사항

- input은 **최소 너비**를 가진다.
- input의 너비는 <strong>max(최소 너비, 입력값이 차지하는 너비)</strong>이다.

## 아이디어

유저가 입력할 때마다, input의 너비를 업데이트하면 된다. 그렇다면, **입력할 때마다 input 너비를 어떤 값으로 업데이트해야 할까?**

문자마다 너비를 `W` px이라고 가정하고, 입력할 때마다 input의 너비를 `입력값 길이 * W` px로 설정하는 아이디어를 떠올릴 수 있다. 하지만 영어, 한글, 공백 등 문자마다 너비가 다르기 때문에, 정확한 (입력값의) 너비가 아니다.

또 다른 아이디어는 input 태그와 같은 스타일링을 적용한, 화면에 표시되지 않는 span 태그를 사용하는 것이다. 입력한 값을 span의 `textContent`로 설정하고, span 태그의 너비를 측정해 input의 너비로 설정한다. **유저가 입력한 값의 너비를 측정하기 위해, span 태그를 사용**한 것이다.

span 태그를 활용하는 두 번째 아이디어로 개발을 시작했다.

## 첫 번째 시도

```tsx title="auto-resize-hashtag-input.tsx" showLineNumbers {28-34, 54-56}
import styled from "@emotion/styled";
import {
  useRef,
  useState,
  type ChangeEventHandler,
  type KeyboardEventHandler,
} from "react";

type Props = {
  value: string;
  onValueChange: (value: string) => void;
  onEnter: () => void;
};

const INITIAL_WIDTH_IN_PX = 60;

export default function AutoResizeHashtagInput({
  value,
  onValueChange,
  onEnter,
}: Props) {
  const [widthInPx, setWidthInPx] = useState(INITIAL_WIDTH_IN_PX);

  const visuallyHiddenSpanRef = useRef<HTMLSpanElement>(null);

  const handleChange: ChangeEventHandler<HTMLInputElement> = (e) => {
    onValueChange(e.target.value);
    if (visuallyHiddenSpanRef.current) {
      const nextWidth = Math.max(
        visuallyHiddenSpanRef.current.getBoundingClientRect().width,
        INITIAL_WIDTH_IN_PX,
      );
      setWidthInPx(nextWidth);
    }
  };

  const handleKeyDown: KeyboardEventHandler<HTMLInputElement> = (e) => {
    // form 태그 내부에서 AutoResizeHashtagInput 컴포넌트가 사용될 경우
    // enter 입력 시, 브라우저 기본동작으로 폼 제출되는 경우를 방지하기 위함.
    if (e.key === "Enter") {
      e.preventDefault();
    }
  };

  const handleKeyUp: KeyboardEventHandler<HTMLInputElement> = (e) => {
    if (e.key === "Enter") {
      onEnter();
      setWidthInPx(INITIAL_WIDTH_IN_PX);
    }
  };

  return (
    <>
      <VisuallyHiddenSpan ref={visuallyHiddenSpanRef}>
        {value}
      </VisuallyHiddenSpan>
      <Input
        type="text"
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onKeyUp={handleKeyUp}
        widthInPx={widthInPx}
        placeholder="#태그"
      />
    </>
  );
}

// Input, VisuallyHiddenSpan 컴포넌트가 font 관련해서 동일한 스타일을 갖도록 Base 컴포넌트 정의
const Base = styled.div`
  display: inline-block;
  border: none;
  border-radius: 8px;
  outline: none;
  padding: 4px 8px;
  font-size: 1rem;
  font-family: Arial, Helvetica, sans-serif;
`;

const Input = styled(Base.withComponent("input"))<{ widthInPx: number }>`
  width: ${({ widthInPx }) => `${widthInPx}px`};
  background-color: rgb(244, 244, 245);
`;

/*
  white-space: pre;
  - span 태그의 자식에 공백을 유지시키기 위함
  - pre가 아니면 '  hello   world  '를 'hello world'로 화면에 표시함
  - '  hello   world  ' 그대로 표시하려면, pre여야함

  visibility: hidden;
  - span 태그를 시각적으로 가림

  position: absolute;
  left: -9999px;
  - position, left 속성으로 span 태그를 화면에 표시되지 않는 위치로 이동
*/
const VisuallyHiddenSpan = styled(Base.withComponent("span"))`
  white-space: pre;
  visibility: hidden;
  position: absolute;
  left: -9999px;
`;
```

54-56번째 줄 코드에서 span 태그의 자식으로 `value` prop을 두었다. 28-34번째 줄 코드에서 사용자가 입력했을 때 `visuallyHiddenSpanRef.current.getBoundingClientRect().width`로 span 태그의 너비를 측정하고, 이 값을 인자로 `setWidthInPx` 함수를 호출해 input의 너비를 업데이트했다.

잘 동작할 것 같았지만 아래 그림처럼 잘 동작하지 않았다.

![첫 번째 시도](/images/posts/2024/auto-resize-input/auto-resize-input-try-1.gif)

**입력값 전부를 표시할 정도로 늘어나지 못해, 제일 앞 문자 하나가 덜 표시되는 문제가 생겼다.** `handleChange`가 호출된 시점에서 `e.target.value`는 유저의 마지막 입력값을 가지지만, `value` prop은 바로 직전의 입력값을 가진다. 따라서 이 시점에서 `visuallyHiddenSpanRef.current.getBoundingClientRect().width`를 참조해도 직전 입력값의 너비일 뿐이다. 그래서 마지막 입력값 전부를 표시할 정도로 늘어나지 않고, 직전 입력값의 너비 정도로 늘어나 앞의 한 문자가 잘렸다.

## 두 번째 시도: useEffect 활용

```tsx title="auto-resize-hashtag-input.tsx" showLineNumbers {27-35}
import styled from "@emotion/styled";
import {
  useEffect,
  useRef,
  useState,
  type ChangeEventHandler,
  type KeyboardEventHandler,
} from "react";

type Props = {
  value: string;
  onValueChange: (value: string) => void;
  onEnter: () => void;
};

const INITIAL_WIDTH_IN_PX = 60;

export default function AutoResizeHashtagInput({
  value,
  onValueChange,
  onEnter,
}: Props) {
  const [widthInPx, setWidthInPx] = useState(INITIAL_WIDTH_IN_PX);

  const visuallyHiddenSpanRef = useRef<HTMLSpanElement>(null);

  useEffect(() => {
    if (visuallyHiddenSpanRef.current) {
      const nextWidth = Math.max(
        visuallyHiddenSpanRef.current.getBoundingClientRect().width,
        INITIAL_WIDTH_IN_PX,
      );
      setWidthInPx(nextWidth);
    }
  }, [value]);

  const handleChange: ChangeEventHandler<HTMLInputElement> = (e) => {
    onValueChange(e.target.value);
  };

  const handleKeyDown: KeyboardEventHandler<HTMLInputElement> = (e) => {
    // form 태그 내부에서 AutoResizeHashtagInput 컴포넌트가 사용될 경우
    // enter 입력 시, 브라우저 기본동작으로 폼 제출되는 경우를 방지하기 위함.
    if (e.key === "Enter") {
      e.preventDefault();
    }
  };

  const handleKeyUp: KeyboardEventHandler<HTMLInputElement> = (e) => {
    if (e.key === "Enter") {
      onEnter();
      setWidthInPx(INITIAL_WIDTH_IN_PX);
    }
  };

  return (
    <>
      <VisuallyHiddenSpan ref={visuallyHiddenSpanRef}>
        {value}
      </VisuallyHiddenSpan>
      <Input
        type="text"
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onKeyUp={handleKeyUp}
        widthInPx={widthInPx}
        placeholder="#태그"
      />
    </>
  );
}

const Base = styled.div`
  display: inline-block;
  border: none;
  border-radius: 8px;
  outline: none;
  padding: 4px 8px;
  font-size: 1rem;
  font-family: Arial, Helvetica, sans-serif;
`;

const Input = styled(Base.withComponent("input"))<{ widthInPx: number }>`
  width: ${({ widthInPx }) => `${widthInPx}px`};
  background-color: rgb(244, 244, 245);
`;

const VisuallyHiddenSpan = styled(Base.withComponent("span"))`
  white-space: pre;
  position: absolute;
  visibility: hidden;
  left: -9999px;
`;
```

**`value` prop이 변경되어 re-rendering 된 후, 마지막 입력값이 반영된 span의 너비를 측정하고 input의 너비를 업데이트하기 위해,** `useEffect`를 활용했다.

`visuallyHiddenSpanRef.current.getBoundingClientRect().width`로 span의 너비를 측정하고 `setWidthInPx` 함수를 호출해 input의 너비를 업데이트하는 코드의 위치를 `handleChange`에서 `useEffect`로 변경했다.

**제일 앞 문자 하나가 덜 표시되는 문제가 해결되었다.**

![두 번째 시도](/images/posts/2024/auto-resize-input/auto-resize-input-try-2.gif)

하지만, **입력값이 깜빡이는(덜덜거리는) 문제가 발생했다.**

## 세 번째 시도: useLayoutEffect 활용

```tsx title="auto-resize-hashtag-input.tsx" showLineNumbers {27-35}
import styled from "@emotion/styled";
import {
  useLayoutEffect,
  useRef,
  useState,
  type ChangeEventHandler,
  type KeyboardEventHandler,
} from "react";

type Props = {
  value: string;
  onValueChange: (value: string) => void;
  onEnter: () => void;
};

const INITIAL_WIDTH_IN_PX = 60;

export default function AutoResizeHashtagInput({
  value,
  onValueChange,
  onEnter,
}: Props) {
  const [widthInPx, setWidthInPx] = useState(INITIAL_WIDTH_IN_PX);

  const visuallyHiddenSpanRef = useRef<HTMLSpanElement>(null);

  useLayoutEffect(() => {
    if (visuallyHiddenSpanRef.current) {
      const nextWidth = Math.max(
        visuallyHiddenSpanRef.current.getBoundingClientRect().width,
        INITIAL_WIDTH_IN_PX,
      );
      setWidthInPx(nextWidth);
    }
  }, [value]);

  const handleChange: ChangeEventHandler<HTMLInputElement> = (e) => {
    onValueChange(e.target.value);
  };

  const handleKeyDown: KeyboardEventHandler<HTMLInputElement> = (e) => {
    // form 태그 내부에서 AutoResizeHashtagInput 컴포넌트가 사용될 경우
    // enter 입력 시, 브라우저 기본동작으로 폼 제출되는 경우를 방지하기 위함.
    if (e.key === "Enter") {
      e.preventDefault();
    }
  };

  const handleKeyUp: KeyboardEventHandler<HTMLInputElement> = (e) => {
    if (e.key === "Enter") {
      onEnter();
      setWidthInPx(INITIAL_WIDTH_IN_PX);
    }
  };

  return (
    <>
      <VisuallyHiddenSpan ref={visuallyHiddenSpanRef}>
        {value}
      </VisuallyHiddenSpan>
      <Input
        type="text"
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onKeyUp={handleKeyUp}
        widthInPx={widthInPx}
        placeholder="#태그"
      />
    </>
  );
}

const Base = styled.div`
  display: inline-block;
  border: none;
  border-radius: 8px;
  outline: none;
  padding: 4px 8px;
  font-size: 1rem;
  font-family: Arial, Helvetica, sans-serif;
`;

const Input = styled(Base.withComponent("input"))<{ widthInPx: number }>`
  width: ${({ widthInPx }) => `${widthInPx}px`};
  background-color: rgb(244, 244, 245);
`;

const VisuallyHiddenSpan = styled(Base.withComponent("span"))`
  white-space: pre;
  position: absolute;
  visibility: hidden;
  left: -9999px;
`;
```

**`value` prop의 변경만 반영해 웹 브라우저가 화면을 새로 그리고 난 후에 `useEffect`의 effect 함수가 실행되어, 한 단계 늦게 input의 너비가 늘어나서** 입력값이 깜빡이는 문제가 발생했다.

**`value` prop의 변경 후, effect 함수를 동기적으로 실행시켜 `widthInPx` 상태 변화까지 완료되고 나서 웹 브라우저가 화면을 페인트 하도록 만들기 위해,** `useEffect` 대신 `useLayoutEffect`를 사용했다.

`useLayoutEffect`는 `useEffect`와 비슷하지만, effect 함수를 모두 실행시키고 나서 웹 브라우저가 페인팅을 하는 것을 보장하는 차이점이 있다.

[React 공식 문서](https://react.dev/reference/react/useLayoutEffect)에도, 깜빡거리는 문제가 발생하거나 브라우저가 페인트 하기 전에 effect 함수가 반드시 완료되어야 하는 경우는 `useEffect` 대신 `useLayoutEffect`를 사용하면 된다고 설명한다.

![세 번째 시도](/images/posts/2024/auto-resize-input/auto-resize-input-try-3.gif)

`useEffect`를 사용할 때와 달리 **깜빡거림 없이 잘 동작함을 확인할 수 있다.**

## 최종 구현: useLayoutEffect 제거 / 다시 handleChange 함수에서 input의 너비를 업데이트하기

앞서 `useLayoutEffect`를 이용해 구현한 코드도 문제가 없었지만, `handleChange` 함수 내부에서도 현재 입력값을 자식으로 가지는 span의 너비를 정확하게 알아낼 방법이 생각나서 적용하기로 했다.

기존에는 너비 업데이트를 `useLayoutEffect`에서, 값 업데이트를 `handleChange`에서 처리했다. **너비와 값 업데이트를 모두 `handleChange`에서 처리할 수 있다면,** 유저의 입력과 연관된 **상태 변화를 한곳에서 처리하게 되어 코드가 간결해질 것이라 생각**했다.

```tsx title="auto-resize-hashtag-input.tsx" showLineNumbers {28-35, 55}
import styled from "@emotion/styled";
import {
  useRef,
  useState,
  type ChangeEventHandler,
  type KeyboardEventHandler,
} from "react";

type Props = {
  value: string;
  onValueChange: (value: string) => void;
  onEnter: () => void;
};

const INITIAL_WIDTH_IN_PX = 60;

export default function AutoResizeHashtagInput({
  value,
  onValueChange,
  onEnter,
}: Props) {
  const [widthInPx, setWidthInPx] = useState(INITIAL_WIDTH_IN_PX);

  const visuallyHiddenSpanRef = useRef<HTMLSpanElement>(null);

  const handleChange: ChangeEventHandler<HTMLInputElement> = (e) => {
    onValueChange(e.target.value);
    if (visuallyHiddenSpanRef.current) {
      visuallyHiddenSpanRef.current.textContent = e.target.value;
      const nextWidth = Math.max(
        visuallyHiddenSpanRef.current.getBoundingClientRect().width,
        INITIAL_WIDTH_IN_PX,
      );
      setWidthInPx(nextWidth);
    }
  };

  const handleKeyDown: KeyboardEventHandler<HTMLInputElement> = (e) => {
    // form 태그 내부에서 AutoResizeHashtagInput 컴포넌트가 사용될 경우
    // enter 입력 시, 브라우저 기본동작으로 폼 제출되는 경우를 방지하기 위함.
    if (e.key === "Enter") {
      e.preventDefault();
    }
  };

  const handleKeyUp: KeyboardEventHandler<HTMLInputElement> = (e) => {
    if (e.key === "Enter") {
      onEnter();
      setWidthInPx(INITIAL_WIDTH_IN_PX);
    }
  };

  return (
    <>
      <VisuallyHiddenSpan ref={visuallyHiddenSpanRef} />
      <Input
        type="text"
        value={value}
        onChange={handleChange}
        onKeyDown={handleKeyDown}
        onKeyUp={handleKeyUp}
        widthInPx={widthInPx}
        placeholder="# 태그"
      />
    </>
  );
}

const Base = styled.div`
  display: inline-block;
  border: none;
  border-radius: 8px;
  outline: none;
  padding: 4px 8px;
  font-size: 1rem;
  font-family: Arial, Helvetica, sans-serif;
`;

const Input = styled(Base.withComponent("input"))<{ widthInPx: number }>`
  width: ${({ widthInPx }) => `${widthInPx}px`};
  background-color: rgb(244, 244, 245);
`;

const VisuallyHiddenSpan = styled(Base.withComponent("span"))`
  white-space: pre;
  position: absolute;
  visibility: hidden;
  left: -9999px;
`;
```

`handleChange` 함수 내부에서 ref로 직접 span에 접근해 `textContent` 값을 `e.target.value`로 갱신하고(29번째 줄), 그 후 측정한 span의 너비로 `widthInPx` 상태를 업데이트했다.

ref로 `textContent` 값을 직접 변경하므로, span의 자식으로 `value` prop을 두는 코드는 제거했다. (55번째 줄)

input의 **값과 너비를 업데이트하는 코드를 `handleChange` 함수, 한 곳에 위치시켜 좀 더 읽기 편한 코드**가 되었다.

![최종 구현](/images/posts/2024/auto-resize-input/auto-resize-input-final.gif)

`useLayoutEffect`를 사용했을 때와 마찬가지로 깜빡임 없이 **잘 동작한다.**

## 활용 예시

만든 `AutoResizeHashtagInput` 컴포넌트를 활용해서 실무에서는 다음과 비슷한 UI를 가지는 폼을 만들었다.

![활용 예시](/images/posts/2024/auto-resize-input/auto-resize-input-example.gif)

클라이언트 코드는 다음과 같다.

```tsx title="app.tsx"
import { useState } from "react";
import styled from "@emotion/styled";
import AutoResizeHashtagInput from "./auto-resize-hashtag-input";

export default function App() {
  const [hashtag, setHashtag] = useState("");

  const [hashtagSet, setHashtagSet] = useState<Set<string>>(() => new Set());

  const handleChange = (hashtag: string) => {
    setHashtag(hashtag);
  };

  const handleEnter = () => {
    if (hashtag === "") return;

    const nextHashtagSet = new Set(hashtagSet);
    nextHashtagSet.add(hashtag);
    setHashtagSet(nextHashtagSet);
    setHashtag("");
  };

  return (
    <section>
      <h2>Hashtags</h2>
      <Hashtags>
        {[...hashtagSet].map((tag) => (
          <Hashtag key={tag}>{tag}</Hashtag>
        ))}
        <AutoResizeHashtagInput
          value={hashtag}
          onValueChange={handleChange}
          onEnter={handleEnter}
        />
      </Hashtags>
    </section>
  );
}

const Hashtags = styled.div`
  display: flex;
  flex-flow: wrap;
  gap: 8px;
  width: 320px;
  overflow-x: auto;
  border: 1px solid gray;
  border-radius: 8px;
  padding: 8px;
  margin-top: 8px;
`;

const Hashtag = styled.div`
  border: 1px solid gray;
  background-color: rgb(244, 244, 245);
  border-radius: 8px;
  outline: none;
  padding: 4px 8px;
  font-size: 1rem;
  font-family: Arial, Helvetica, sans-serif;
  white-space: pre;
`;
```

## 소감

입력값에 따라 알아서 너비가 늘어나고 줄어드는 input 컴포넌트를 React를 이용해 만들었다. 생각보다 간단하지 않았고, 구현할 때마다 버그가 생겨서 해결하려고 노력했다.

최종 구현에서는 `useEffect`나 `useLayoutEffect`를 사용하지 않았지만, 구현 과정에서 이 둘의 차이를 직접 눈으로 확인할 수 있어서 좋았다.
20:T4cfe,
회사 업무를 하면서 상태 관리 도구로 MobX를 사용하게 되었다. MobX의 핵심 개념, React와 함께 사용하는 방법을 정리했다.

## 핵심 개념

MobX는 일관적인 상태 관리를 위해, 애플리케이션 상태로부터 계산할 수 있는 값을 자동으로 생성하는 방식을 사용한다.

state, derivations, reactions, actions 개념으로 MobX의 동작 방식을 설명할 수 있다.

### state

- 말 그대로 애플리케이션의 **상태**이다.
- 비슷한 역할을 하는 상태를 여러 번 정의하지 않도록 잘 설계해야 한다. (**single source of truth**)

### derivations

- **state로부터 계산할 수 있는 모든 값**이다.
- state가 변경되면 **자동**으로 계산된다.
- 예시
  - todos 상태 -> 아직 완료되지 않은 일의 개수 계산 가능
  - todos 상태 -> 할 일 목록을 표현하는 HTML 생성 가능

### reactions

- derivations와 비슷하지만, **값을 생성하지 않고 작업을 수행**한다.
- I/O 같은 작업이 될 수 있다.
  - 상태 변화에 따른 DOM 갱신
  - 상태 변화에 따른 네트워크 요청

### actions

- **state를 변경**하는 모든 것

## MobX를 쓰면 편리한 점 (with 채팅룸 상태 관리 예제 코드)

### MobX를 쓰지 않을 때

채팅룸 데이터를 관리하는 `ChatRoomStore` class를 다음과 같이 작성할 수 있다.

```ts title="chat-room-store.ts"
type ChatRoom = {
  name: string;
};

class ChatRoomStore {
  #chatRooms: ChatRoom[];

  constructor() {
    this.#chatRooms = [];
  }

  get recentlyCreatedChatRoom() {
    return this.#chatRooms.at(-1);
  }

  get report() {
    let message = `개수: ${this.#chatRooms.length}`;
    if (this.recentlyCreatedChatRoom) {
      message += `, 최근 생성: ${this.recentlyCreatedChatRoom.name}`;
    }
    return message;
  }

  createChatRoom(name: string) {
    this.#chatRooms.push({ name });
  }

  renameChatRoom(oldName: string, newName: string) {
    const chatRoom = this.#chatRooms.find((room) => room.name === oldName);
    if (chatRoom) {
      chatRoom.name = newName;
    }
  }
}
```

일반적인 class 코드이다.

- `#chatRooms` private property: 채팅룸들을 배열로 관리
- `recentlyCreatedChatRoom` getter: 최근에 생성된 채팅룸 조회
- `report` getter: 전체 채팅룸의 개수와 최근 생성된 채팅룸 이름을 문자열 형태로 조회
- `createChatRoom` method: 새 채팅룸 생성
- `renameChatRoom` method: 채팅룸 이름 변경

```ts title="chat-room-store-test.ts"
const chatRoomStore = new ChatRoomStore();
console.log(chatRoomStore.report);

chatRoomStore.createChatRoom("React study 룸");
console.log(chatRoomStore.report);

chatRoomStore.createChatRoom("MobX study 룸");
console.log(chatRoomStore.report);

chatRoomStore.createChatRoom("JS study 룸");
console.log(chatRoomStore.report);

chatRoomStore.renameChatRoom("JS study 룸", "Java study 룸");
console.log(chatRoomStore.report);

chatRoomStore.renameChatRoom("React study 룸", "Next.js study 룸");
console.log(chatRoomStore.report);
```

`ChatRoomStore` 타입의 인스턴스를 생성하고, `createChatRoom`과 `renameChatRoom`을 호출해 store 내부의 상태를 바꾸었다. 인스턴스 생성 후와 store 내부의 상태가 변경된 후의 **변경 사항을 알기 위해** `console.log`를 활용해 `report` 값을 출력했다. 실행 결과는 아래와 같다.

![pure-chat-room-store](/images/posts/2023/how-to-use-mobx/pure-chat-room-store-result.webp)

### MobX를 쓸 때

`chat-room-store-test.ts`에서는 `ChatRoomStore`의 변경사항을 확인하기 위해 매번 직접 `console.log`를 호출했다. 하지만, MobX를 활용하면 `console.log`를 직접 호출하는 대신, **store의 변경사항이 있을 때 `console.log`가 자동으로 호출**되게 만들 수 있다.

앞서 언급한 state, derivations, reactions, actions를 생각하면서

store의

- `#chatRooms` -> state로 등록
- `recentlyCreatedChatRoom` -> derivation으로 등록
- `report` -> derivation으로 등록, `report`를 로깅하는 함수를 reaction으로 등록
- `createChatRoom` -> action으로 등록
- `renameChatRoom` -> action으로 등록

하면 된다.

동작 방식은 다음과 같다.

1. `createChatRoom`, `renameChatRoom` action에 의해 `#chatRooms` state가 변경됨
2. `#chatRooms` state 변경에 의해 `recentlyCreatedChatRoom`, `report` derivation이 자동으로 다시 계산됨
3. `#chatRooms` state 변경에 의해 `report` 값이 변경되었다면 `report`를 로깅하는 함수를 reaction으로 등록했기 때문에, 변경된 `report` 값이 출력됨

**MobX를 사용하면, state 변화에 반응하는 Reactive한 코드를 쉽게 작성할 수 있다.**

```ts title="observable-chat-room-store.ts" showLineNumbers {1, 8, 12-19}
import { action, autorun, computed, makeObservable, observable } from "mobx";

type ChatRoom = {
  name: string;
};

class ObservableChatRoomStore {
  private chatRooms: ChatRoom[];

  constructor() {
    this.chatRooms = [];
    makeObservable<ObservableChatRoomStore, "chatRooms">(this, {
      chatRooms: observable,
      recentlyCreatedChatRoom: computed,
      report: computed,
      createChatRoom: action,
      renameChatRoom: action,
    });
    autorun(() => console.log(this.report));
  }

  get recentlyCreatedChatRoom() {
    return this.chatRooms.at(-1);
  }

  get report() {
    let message = `개수: ${this.chatRooms.length}`;
    if (this.recentlyCreatedChatRoom) {
      message += `, 최근 생성: ${this.recentlyCreatedChatRoom.name}`;
    }
    return message;
  }

  createChatRoom(name: string) {
    this.chatRooms.push({ name });
  }

  renameChatRoom(oldName: string, newName: string) {
    const chatRoom = this.chatRooms.find((room) => room.name === oldName);
    if (chatRoom) {
      chatRoom.name = newName;
    }
  }
}
```

MobX를 이용해서 `chatRooms` state 변화에 반응하는 `ObservableChatRoomStore` class를 작성했다.

먼저, `8`번째 줄에서 JavaScript의 private 프로퍼티(`#`) 대신, TypeScript의 private 접근 제어자를 사용하도록 변경했다. MobX의 `make(Auto)Observable` 함수가 `#`을 지원하지 않기 때문이다.

`12` 번째 줄의 `makeObservable` 함수는 property, method, getter 등을 state, derivations, actions으로 등록하는 함수이다. private 프로퍼티의 경우, `makeObservable` 함수가 타입을 찾지 못하기 때문에 직접 제네릭 인자로 `"chatRooms"`라는 프로퍼티 이름을 넘겨주었다. (안 그러면 타입 에러가 발생한다.)

`13` 번째 줄의 `observable`은 `chatRooms`를 state로 등록하겠다는 의미이다.

`14-15` 번째 줄의 `computed`는 `recentlyCreatedChatRoom`, `report`를 derivation으로 등록하겠다는 의미이다.

`16-17` 번째 줄의 `action`은 `createChatRoom`, `renameChatRoom`을 action로 등록하겠다는 의미이다.

`19` 번째 줄의 `autorun`은 인자로 넘긴 콜백함수를 reaction으로 등록하겠다는 의미이다.

```ts title="observable-chat-room-store-test.ts" showLineNumbers
const observableChatRoomStore = new ObservableChatRoomStore();

observableChatRoomStore.createChatRoom("React study 룸");

observableChatRoomStore.createChatRoom("MobX study 룸");

observableChatRoomStore.createChatRoom("JS study 룸");

observableChatRoomStore.renameChatRoom("JS study 룸", "Java study 룸");

observableChatRoomStore.renameChatRoom("React study 룸", "Next.js study 룸");
```

`ObservableChatRoomStore`의 인스턴스를 생성하고, `createChatRoom`, `renameChatRoom`을 호출해 store 상태를 변경했다. 실행 결과는 아래와 같다.

![observable-chat-room-store-result](/images/posts/2023/how-to-use-mobx/observable-chat-room-store-result.webp)

`createChatRoom`, `renameChatRoom` 메서드를 호출하는 코드만 있고, `console.log`를 호출하는 코드는 없다. 하지만, `report`을 로깅하는 함수를 reaction으로 등록해 두었기 때문에, `chatRooms`의 변경에 따라 `report` 값이 변경되면 로그가 찍힌다.

- `1` 번째 줄에 의해 **"개수: 0"** 출력
- `3` 번째 줄에 의해 **"개수: 1, 최근 생성: React study 룸"** 출력
- `5` 번째 줄에 의해 **"개수: 2, 최근 생성: MobX study 룸"** 출력
- `7` 번째 줄에 의해 **"개수: 3, 최근 생성: JS study 룸"** 출력
- `9` 번째 줄에 의해 **"개수: 3, 최근 생성: Java study 룸"** 출력

`11` 번째 줄에 의해 상태가 변했지만, reaction이 수행되지 않아 로그가 찍히지 않았다. "React Study 룸"의 이름이 "Next.js study 룸"으로 바뀌는 상태 변화가 발생했지만, `report`의 값은 "개수: 3, 최근 생성: Java study 룸"으로 바뀌지 않았다. 등록한 reaction에서는 `report` 값만 출력하는 데, `chatRooms` 상태가 바뀌어도 `report` 값은 바뀌지 않아서 reaction이 수행되지 않았다.

또 하나 알아두면 좋은 것은, `chatRooms`라는 배열을 `observable`로 선언했는데, 배열 요소의 프로퍼티 변화도 감지한다는 것이다.

## React와 함께 사용하기 (with 채팅룸 컴포넌트 예제 코드)

`mobx-react-lite` 패키지의 `observer` HoC로, React 컴포넌트를 감싸기만 하면 된다. `observer` 내부적으로 컴포넌트를 렌더링 하는 함수를 `autorun`으로 감싸는데, **컴포넌트에서 사용하는 데이터가 변경되었을 때 다시 렌더링하도록 만들어서,** MobX 상태와 컴포넌트를 동기화한다.

### MobX Store 작성

```ts title="chat-room-store.ts"
import { action, computed, makeObservable, observable } from "mobx";

type ChatRoom = {
  name: string;
};

export default class ChatRoomStore {
  private chatRooms: ChatRoom[];

  constructor() {
    this.chatRooms = [];
    makeObservable<ChatRoomStore, "chatRooms">(this, {
      chatRooms: observable,
      list: computed,
      recentlyCreatedChatRoom: computed,
      report: computed,
      createChatRoom: action,
      renameChatRoom: action,
    });
  }

  get list() {
    return this.chatRooms;
  }

  get recentlyCreatedChatRoom() {
    return this.chatRooms.at(-1);
  }

  get report() {
    let message = `개수: ${this.chatRooms.length}`;
    if (this.recentlyCreatedChatRoom) {
      message += `, 최근 생성: ${this.recentlyCreatedChatRoom.name}`;
    }
    return message;
  }

  createChatRoom(name: string) {
    this.chatRooms.push({ name });
  }

  renameChatRoom(oldName: string, newName: string) {
    const chatRoom = this.chatRooms.find((room) => room.name === oldName);
    if (chatRoom) {
      chatRoom.name = newName;
    }
  }
}
```

(앞서 작성한 store와 비슷하게) 채팅룸 상태 관리를 위한 `ChatRoomStore` class를 작성했다.

### MobX Store를 제공하는 Provider 작성

**Store를 여러 컴포넌트에서 공유하기 위해 Context를 사용한다.** 물론, Store 인스턴스를 전역으로 하나 만들어 두고 export 해서 사용해도 된다. 하지만 Context를 이용해 Store를 컴포넌트에 제공하면 Store의 적용 범위를 제한할 수 있어 더 좋은 것 같다.

```tsx title="chat-room-store-provider.tsx" showLineNumbers {12, 14-21}
import {
  createContext,
  type PropsWithChildren,
  useContext,
  useRef,
} from "react";
import ChatRoomStore from "./chat-room-store";

const ChatRoomStoreContext = createContext<ChatRoomStore | null>(null);

export const ChatRoomStoreProvider = ({ children }: PropsWithChildren) => {
  const storeRef = useRef<ChatRoomStore | null>(null);

  const getStore = () => {
    if (storeRef.current !== null) {
      return storeRef.current;
    }
    const store = new ChatRoomStore();
    storeRef.current = store;
    return store;
  };

  return (
    <ChatRoomStoreContext value={getStore()}>{children}</ChatRoomStoreContext>
  );
};

export const useChatRoomStore = () => {
  const chatRoomStore = useContext(ChatRoomStoreContext);

  if (!chatRoomStore) {
    throw new Error(
      "ChatRoomStoreProvider 내부에서 useChatRoomStore hook을 사용해야 합니다.",
    );
  }

  return chatRoomStore;
};
```

하위 컴포넌트에 `ChatRoomStore` 인스턴스를 제공하는 `ChatRoomStoreProvider`를 작성했다. `ChatRoomStoreProvider`가 리렌더링 되었을 때, `ChatRoomStore` 인스턴스가 새로 생성되는 것을 방지하기 위해 `ref`로 관리했다. (`14` - `21` 번째 줄)

추가로, Context 하위 컴포넌트에서 `ChatRoomStore` 인스턴스에 접근할 수 있도록 `useChatRoomStore` hook도 작성했다.

### MobX Store에 반응하는 채팅룸 컴포넌트 작성

채팅룸 목록 조회, 생성, 이름 변경 등의 기능을 제공하는 `ChatRoom` 컴포넌트를 만들었다.

```tsx title="chat-room.tsx" showLineNumbers {8, 12, 14, 16, 19}
import { ChatRoomStoreProvider } from "./store/chat-room-store-provider";
import ChatRoomCreateButton from "./components/chat-room-create-button";
import ChatRoomList from "./components/chat-room-list";
import ChatRoomReportMessage from "./components/chat-room-report-message";

const ChatRoom = () => {
  return (
    <ChatRoomStoreProvider>
      <section className="p-1 w-80 max-h-80 overflow-y-hidden flex flex-col gap-2">
        <header className="p-0.5 flex justify-between items-center">
          <h2 className="text-lg font-bold">채팅룸 목록</h2>
          <ChatRoomCreateButton />
        </header>
        <ChatRoomReportMessage />
        <div className="grow overflow-y-auto">
          <ChatRoomList />
        </div>
      </section>
    </ChatRoomStoreProvider>
  );
};

export default ChatRoom;
```

`8`, `19` 번째 줄에서 `ChatRoomStoreProvider`를 사용했다. 따라서 자식 컴포넌트인 `ChatRoomCreationButton`, `ChatRoomReportMessage`, `ChatRoomList` 컴포넌트에서 Context를 통해 `ChatRoomStore` 인스턴스에 접근할 수 있다.

```tsx title="chat-room-create-button.tsx" showLineNumbers {4, 5, 10}
import { observer } from "mobx-react-lite";
import { useChatRoomStore } from "../store/chat-room-store-provider";

const ChatRoomCreateButton = observer(() => {
  const chatRoomStore = useChatRoomStore();

  const handleClickButton = () => {
    const chatRoomName = window.prompt("채팅룸 이름을 입력하세요.");
    if (!chatRoomName) return;
    chatRoomStore.createChatRoom(chatRoomName);
  };

  return (
    <button
      type="button"
      onClick={handleClickButton}
      className="border border-gray-400 rounded-md p-0.5 cursor-pointer"
    >
      채팅룸 생성
    </button>
  );
});

export default ChatRoomCreateButton;
```

`ChatRoomCreateButton` 컴포넌트의 `4` 번째 줄에서 **MobX Store와 동기화되는 컴포넌트로 만들기 위해 `observer` HoC로 감쌌다.**

`5`번째 줄에서 `ChatRoomStore` 인스턴스에 접근하기 위해 `useChatRoomStore` hook을 사용했다.

(`10`번째 줄의) 채팅룸 생성 버튼 click 이벤트 핸들러 내부에서 **`createChatRoom` action을 통해 새로운 채팅룸을 추가했다. (store의 상태를 변경했다.)**

```tsx title="chat-room-report-message.tsx" showLineNumbers {4, 5, 7}
import { observer } from "mobx-react-lite";
import { useChatRoomStore } from "../store/chat-room-store-provider";

const ChatRoomReportMessage = observer(() => {
  const chatRoomStore = useChatRoomStore();

  return <p>{chatRoomStore.report}</p>;
});

export default ChatRoomReportMessage;
```

전체 채팅룸 개수와 최근 생성된 채팅룸 이름을 표시하는 `ChatRoomReportMessage` 컴포넌트에서는 `chatRoomStore.report` 값을 표시하고 있다.

`4` 번째 줄에서 **`observer` HoC로 감쌌기 때문에, store에 변경 사항이 생겨서 직접적으로 참조하는 `chatRoomStore.report` 데이터가 변경되면 다시 렌더링 된다.**

```tsx title="chat-room-list.tsx" showLineNumbers {4, 5, 10, 15, 17, 20}
import { observer } from "mobx-react-lite";
import { useChatRoomStore } from "../store/chat-room-store-provider";

const ChatRoomList = observer(() => {
  const chatRoomStore = useChatRoomStore();

  const handleClickRenameButton = (oldName: string) => () => {
    const newName = window.prompt("채팅룸의 새 이름을 입력하세요.");
    if (!newName) return;
    chatRoomStore.renameChatRoom(oldName, newName);
  };

  return (
    <ul className="flex flex-col gap-1">
      {chatRoomStore.list.map((chatRoom) => (
        <li
          key={chatRoom.name}
          className="flex justify-between items-center p-0.5 border border-gray-500 rounded-md"
        >
          {chatRoom.name}
          <button
            type="button"
            onClick={handleClickRenameButton(chatRoom.name)}
            className="border border-gray-400 rounded-md p-0.5 cursor-pointer"
          >
            이름 수정
          </button>
        </li>
      ))}
    </ul>
  );
});

export default ChatRoomList;
```

`ChatRoomList` 컴포넌트에서는 전체 채팅룸 목록을 표시한다. 또, 각 채팅룸의 "이름 수정" 버튼을 통해 이름을 변경할 수 있다.

(`10`번째 줄의) 이름 수정 버튼 click 이벤트 핸들러 내부에서 **`renameChatRoom` action을 통해 채팅룸 이름을 변경했다.** (store의 상태를 변경했다.)

`15`번째 줄에서 `chatRoomStore.list`를 통해 채팅룸 배열을 조회했고, `20` 번째 줄에서는 채팅룸의 이름을 참조했다.

`4` 번째 줄에서 **`observer` HoC로 감쌌기 때문에, store에 변경 사항이 생겨서 `chatRoomStore.list` 같은 참조하는 데이터가 변경되면 다시 렌더링 된다.**

구현 결과는 아래와 같다.

![mobx-chat-room-component](/images/posts/2023/how-to-use-mobx/mobx-chat-room-component.webp)

새 채팅룸을 추가하거나 기존 채팅룸의 이름을 변경하면 **MobX store가 업데이트되고, React 컴포넌트는 MobX store의 변화에 적절하게 반응하면서 리렌더링** 되었다.

## 정리

MobX를 사용해 상태 관리를 편하게 할 수 있다.

- action을 통해 state를 변경
- state가 변경되면 자동으로 derivation 다시 계산
- state, derivation 같은 reaction이 의존하는 데이터가 변경되면 reaction이 다시 수행

위와 같은 동작 방식을 통해, **state의 변화에 반응하는 Reactive한 코드를 쉽게 작성할 수 있다.**

React와 함께 사용하기 위해서 `mobx-react-lite` 패키지의 `observer` HoC로 React 컴포넌트를 감싸면 된다. **`observer`로 래핑된 React 컴포넌트**가 **의존하는 MobX store의 데이터가 변경되면**, **자동으로 React 컴포넌트가 다시 렌더링** 된다. 즉, MobX Store와 React 컴포넌트가 동기화된다.

## 다른 상태 관리 도구와 차별점이라고 생각하는 부분

`useState`, `useReducer` 같은 상태 관련 hook이나 다른 상태 관리 도구를 사용할 때는 상태를 변경할 때 불변성을 지켜야 했다. 객체를 복사해서 새로운 객체를 만들고 나서 변경해야 했다.

MobX를 사용하면 불변성을 지킬 필요가 없기 때문에 객체를 복사하는 수고로움을 덜 수 있고, mutable한 메서드를 사용하거나 프로퍼티를 직접 수정해도 된다. 개인적으로 편리했던 부분이라고 생각한다.

다른 상태 관리 도구를 쓸 땐 class를 거의 사용하지 못했는데, MobX를 쓸 때는 class도 자유롭게 쓸 수 있어서 좀 더 객체 지향적인 코드를 작성할 수도 있다.

## 참고

- [MobX 공식문서](https://mobx.js.org)
- [Ten minute introduction to MobX and React](https://mobx.js.org/getting-started)
21:T6ed1,
회사에서 첫 업무로 유저 프로필 컴포넌트 개발을 맡았다. 프로필 생성/편집 form을 만들면서, 프로필 이미지 파일을 선택하고 프리뷰를 표시하는 기능을 구현했다. 구현 과정에서 겪었던 문제와 새롭게 알게된 내용을 잊어버리기 전에 정리했다. (회사 코드를 그대로 쓸 수 없어서, 간단한 예시 코드를 준비했다.)

## 만들고 싶은 것

(업무하면서 만든 코드는 기능이 더 복잡하지만) 집중해서 정리하고 싶은 부분이 **프로필 이미지 파일 상태관리**와 **프로필 이미지 프리뷰 기능 구현**이기 때문에, 간단한 **프로필 생성 form**을 만드는 과정으로 간략화했다.

![profile-create-form](/images/posts/2023/image-preview-form/profile-create-form-view.png)

요구사항을 정리하면 다음과 같다.

- 닉네임, 프로필 이미지 필드가 있다.
  - 닉네임 필드는 `string`
  - 프로필 이미지 필드는 사용자가 선택한 이미지 파일 또는 기본 이미지
- 카메라 버튼을 누르면 "기본 이미지", "이미지 변경" 메뉴가 포함된 Dropdown이 열린다.
  - "이미지 변경" 메뉴를 클릭하면 (OS가 제공하는) 파일 선택 창이 열린다.
  - 파일 선택 창에서 파일을 선택하면, 해당 파일을 선택한 상태가 되고 선택한 파일의 프리뷰를 표시한다.
  - 파일 선택 창에서 파일을 선택하지 않고 (닫기 클릭, 취소 버튼, ESC 키 등을 통해)창을 닫으면, 기존 이미지 선택이 취소되고 기본 이미지를 선택한다.
  - "기본 이미지" 메뉴를 클릭하면 기존 이미지 선택이 취소되고 기본 이미지를 선택한다.

## 코드 준비

먼저 UI 구조를 구상하고 스타일링을 진행했다.

`ProfileCreateForm`, `ProfileImagePreview`, `ProfileImageDropdownMenu` 3개의 컴포넌트를 준비했다.

### ProfileCreateForm

프로필 생성 form을 의미하는 컴포넌트이다.

```tsx title="profile-create-form.tsx" showLineNumbers {19, 30-32}
import styled from "@emotion/styled";
import ProfileImagePreview from "./profile-image-preview";
import ProfileImageDropdownMenu from "./profile-image-dropdown-menu";

export default function ProfileCreateForm() {
  return (
    <StyledSection>
      <StyledHeading>프로필 만들기</StyledHeading>
      <StyledForm>
        <StyledRelativeBox>
          <ProfileImagePreview previewSource={null} />
          <StyledAbsoluteBox>
            <ProfileImageDropdownMenu
              onClickDefaultImageButton={() => {}}
              onClickChangeImageButton={() => {}}
            />
          </StyledAbsoluteBox>
        </StyledRelativeBox>
        <StyledFileInput type="file" accept="image/png, image/jpeg" />
        <StyledFormField>
          <StyledLabel htmlFor="nickname">닉네임</StyledLabel>
          <StyledTextInput id="nickname" type="text" />
        </StyledFormField>
        <StyledButton type="submit">만들기</StyledButton>
      </StyledForm>
    </StyledSection>
  );
}

const StyledFileInput = styled.input`
  display: none;
`;

const StyledForm = styled.form`
  display: flex;
  flex-direction: column;
  row-gap: 24px;
`;

const StyledSection = styled.section`
  width: 360px;
  border: 1px solid black;
  border-radius: 8px;
  padding: 16px;
`;

const StyledHeading = styled.h2`
  text-align: center;
`;

const StyledLabel = styled.label``;

const StyledTextInput = styled.input`
  padding: 8px;
  border: 1px solid black;
  border-radius: 8px;
`;

const StyledFormField = styled.div`
  display: flex;
  flex-direction: column;
  row-gap: 8px;
`;

const StyledButton = styled.button`
  cursor: pointer;
  border: 1px solid black;
  border-radius: 8px;
  padding: 8px;
  background-color: white;
  :hover {
    background-color: black;
    color: white;
  }
`;

const StyledRelativeBox = styled.div`
  margin: 0 auto;
  position: relative;
`;

const StyledAbsoluteBox = styled.div`
  position: absolute;
  bottom: 4px;
  right: 0px;
`;
```

파일 입력을 다루기 위해 **19번째 줄**에서 file input을 사용했다. 그리고 기본 UI를 사용하지 않을 것이라서 **31번째 줄**에서 `display: none;`으로 설정해 화면에서 가렸다.

### ProfileImagePreview

선택한 파일의 프리뷰를 표시하는 컴포넌트이다.

```tsx title="profile-image-preview.tsx"
import styled from "@emotion/styled";
import defaultImage from "./default-image.svg";

type Props = {
  // previewSource가 null: 기본이미지 표시
  previewSource: string | null;
};

const SIZE = 80;

export default function ProfileImagePreview({ previewSource }: Props) {
  return (
    <StyledImage
      src={previewSource ?? defaultImage}
      width={SIZE}
      height={SIZE}
      alt="profile-image-preview"
    />
  );
}

const StyledImage = styled.img`
  border-radius: 9999px;
`;
```

### ProfileImageDropdownMenu

프로필 이미지 선택 관련 기능(기본 이미지/이미지 변경)을 제공하는 Dropdown 컴포넌트이다. Radix UI를 이용해 구현했다.

```tsx title="profile-image-dropdown-menu.tsx"
import styled from "@emotion/styled";
import * as DropdownMenu from "@radix-ui/react-dropdown-menu";
import { LuCamera } from "react-icons/lu";

type Props = {
  // "기본 이미지" 버튼 클릭 handler.
  onClickDefaultImageButton: () => void;
  // "이미지 변경" 버튼 클릭 handler.
  onClickChangeImageButton: () => void;
};

export default function ProfileImageDropdownMenu({
  onClickChangeImageButton,
  onClickDefaultImageButton,
}: Props) {
  return (
    <DropdownMenu.Root>
      <DropdownMenu.Trigger asChild>
        <StyledTriggerButton>
          <LuCamera size={16} />
        </StyledTriggerButton>
      </DropdownMenu.Trigger>

      <DropdownMenu.Portal>
        <StyledDropdownMenuContent side="right" sideOffset={8} align="center">
          <StyledDropdownMenuItem onSelect={onClickDefaultImageButton}>
            기본 이미지
          </StyledDropdownMenuItem>
          <StyledDropdownMenuItem onSelect={onClickChangeImageButton}>
            이미지 변경
          </StyledDropdownMenuItem>
        </StyledDropdownMenuContent>
      </DropdownMenu.Portal>
    </DropdownMenu.Root>
  );
}

const StyledTriggerButton = styled.button`
  background-color: black;
  color: white;
  border-radius: 9999px;
  padding: 3px;
  border: 1px solid white;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
`;

const StyledDropdownMenuContent = styled(DropdownMenu.Content)`
  border: 1px solid black;
  border-radius: 8px;
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  row-gap: 4px;
`;

const StyledDropdownMenuItem = styled(DropdownMenu.DropdownMenuItem)`
  cursor: pointer;
  padding: 4px 12px;
  :hover {
    background-color: lightgray;
  }
  :focus {
    outline: 0;
  }
`;
```

## "이미지 변경" 메뉴를 클릭했을 때, 파일 선택 창 열기

앞서 `display: none;`으로 file input을 가렸기 때문에, 파일 선택 창을 열 수 있는 방법이 없다. "이미지 변경" 메뉴를 클릭했을 때 파일 선택 창을 열어주는 기능을 만들어야 한다.

```tsx title="profile-create-form.tsx" showLineNumbers {2, 4-7, 18, 25}
export default function ProfileCreateForm() {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleClickChangeImageButton = () => {
    if (!fileInputRef.current) return;
    fileInputRef.current.click();
  };

  return (
    <StyledSection>
      <StyledHeading>프로필 만들기</StyledHeading>
      <StyledForm>
        <StyledRelativeBox>
          <ProfileImagePreview previewSource={null} />
          <StyledAbsoluteBox>
            <ProfileImageDropdownMenu
              onClickDefaultImageButton={() => {}}
              onClickChangeImageButton={handleClickChangeImageButton}
            />
          </StyledAbsoluteBox>
        </StyledRelativeBox>
        <StyledFileInput
          type="file"
          accept="image/png, image/jpeg"
          ref={fileInputRef}
        />
        <StyledFormField>
          <StyledLabel htmlFor="nickname">닉네임</StyledLabel>
          <StyledTextInput id="nickname" type="text" />
        </StyledFormField>
        <StyledButton type="submit">만들기</StyledButton>
      </StyledForm>
    </StyledSection>
  );
}
```

file input에 접근할 수 있도록, ref를 활용했다. 그리고 **6번째 줄**에서 file input element의 click 메서드를 호출해 파일 선택 창을 열었다.

## form 상태 관리

react-hook-form 같은 form 라이브러리를 사용해도 되지만, 지금은 **프로필 이미지 파일 처리에 집중**할 것이므로 간단하게 `useState`를 이용해 form 상태 관리를 할 것이다. (validation도 생략!)

```tsx title="profile-create-form.tsx" showLineNumbers {1, 8-10, 21-31, 33-39, 44, 58}
type ProfileImage = { type: "default" } | { type: "file"; file: File };

export default function ProfileCreateForm() {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [nicknameField, setNicknameField] = useState("");

  const [profileImageField, setProfileImageField] = useState<ProfileImage>({
    type: "default",
  });

  const handleClickChangeImageButton = () => {
    if (!fileInputRef.current) return;
    fileInputRef.current.click();
  };

  const handleChangeNickname: ChangeEventHandler<HTMLInputElement> = (e) => {
    setNicknameField(e.target.value);
  };

  const handleChangeProfileImageFile: ChangeEventHandler<HTMLInputElement> = (
    e,
  ) => {
    const selectedFile = e.target.files?.[0];

    if (!selectedFile) {
      setProfileImageField({ type: "default" });
    } else {
      setProfileImageField({ type: "file", file: selectedFile });
    }
  };

  const handleSubmit: FormEventHandler<HTMLFormElement> = (e) => {
    e.preventDefault();

    window.alert(
      `[닉네임: ${nicknameField} / 이미지: ${profileImageField.type === "default" ? "기본 이미지" : profileImageField.file.name}] 프로필 생성 완료!`,
    );
  };

  return (
    <StyledSection>
      <StyledHeading>프로필 만들기</StyledHeading>
      <StyledForm onSubmit={handleSubmit}>
        <StyledRelativeBox>
          <ProfileImagePreview previewSource={null} />
          <StyledAbsoluteBox>
            <ProfileImageDropdownMenu
              onClickDefaultImageButton={() => {}}
              onClickChangeImageButton={handleClickChangeImageButton}
            />
          </StyledAbsoluteBox>
        </StyledRelativeBox>
        <StyledFileInput
          type="file"
          accept="image/png, image/jpeg"
          ref={fileInputRef}
          onChange={handleChangeProfileImageFile}
        />
        <StyledFormField>
          <StyledLabel htmlFor="nickname">닉네임</StyledLabel>
          <StyledTextInput
            id="nickname"
            type="text"
            value={nicknameField}
            onChange={handleChangeNickname}
          />
        </StyledFormField>
        <StyledButton type="submit">만들기</StyledButton>
      </StyledForm>
    </StyledSection>
  );
}
```

위의 코드는, form 상태관리를 추가한 `ProfileCreateForm` 컴포넌트 코드이다.

```ts
type ProfileImage = { type: "default" } | { type: "file"; file: File };
```

먼저 **기본 이미지를 선택한 상태**와 **이미지 파일을 선택한 상태**를 표현하기 위해 `ProfileImage` 타입을 정의했다.

```ts
const [profileImageField, setProfileImageField] = useState<ProfileImage>({
  type: "default",
});
```

`useState`로 프로필 이미지 필드 상태를 관리하는 데, 기본 이미지가 선택된 상황을 의미하는 `{ type: "default" }`로 초기화 했다.

```tsx {4}
const handleChangeProfileImageFile: ChangeEventHandler<HTMLInputElement> = (
  e,
) => {
  const selectedFile = e.target.files?.[0];

  if (!selectedFile) {
    // 선택한 파일이 없는 경우: 기본 이미지를 선택한 상태로 업데이트
    setProfileImageField({ type: "default" });
  } else {
    // 파일 선택창에서 파일을 선택한 경우: 선택한 파일을 선택한 상태로 업데이트
    setProfileImageField({ type: "file", file: selectedFile });
  }
};
```

파일 선택 창에서 파일을 변경한 경우, file input에서 change event가 발생한다. 단, **동일한 파일을 선택한 경우 change event가 발생하지 않는다.** (파일 A가 선택된 상황에서 다시 파일 A를 선택한 경우) 또, **파일이 선택된 상태에서 파일을 선택하지 않은 상태가 되어도 change event가 발생한다.** (**파일 선택 창에서 파일 선택을 하지 않고** 닫기/취소 버튼을 누르거나 ESC키를 눌러 **파일 선택 창을 닫으면 파일을 선택하지 않은 상태가 된다.**)

input element의 `files` 속성으로 선택된 파일 목록에 접근할 수 있다. `FileList` 타입이며 순회 가능하다. (지금은 `multiple` 속성을 사용하지 않아서 하나의 파일만 선택할 수있다.)

`e.target.files?.[0]`으로 첫 번째로 선택된 파일에 접근했고, 선택된 파일이 있는 경우와 없는 경우에 따라 form 상태를 업데이트했다.

처음에는 버그있는 코드를 작성하기도 했는데, `handleChangeProfileImageFile` 함수를 다음과 같이 작성했었다.

```ts
const handleChangeProfileImageFile: ChangeEventHandler<HTMLInputElement> = (
  e,
) => {
  const files = e.target.files;

  if (!files) {
    setProfileImageField({ type: "default" });
  } else {
    setProfileImageField({ type: "file", file: files[0] });
  }
};
```

얼핏 보면 맞는 코드 같다.

하지만 이렇게 코드를 짜면, **이미지를 선택한 상태**에서 (파일 선택 창을 다시 열고 아무 파일도 선택하지 않고 창을 닫아서) **이미지를 선택하지 않은 상태**가 되었을 때 `setProfileImageField({ type: "default" })`를 호출하지 않고, `setProfileImageField({ type: "file", file: files[0] })`를 호출하는 문제가 발생한다. (else 문이 실행된다. 코드를 짤 때 의도했던 바는 if 문이 실행되는 것이었다.)

심지어 코드가 실행되면서 else문에서 `files[0]`으로 접근하면 선택한 파일이 없기에 `undefined` 값을 얻어서, 코드 작성 시점에 TypeScript가 추론한 타입(`File`)과 런타임의 타입(`undefined`)이 달라지는 문제도 생긴다.

위 코드를 짤 때 TypeScript의 도움으로 `e.target.files`의 타입이 `FileList | null` 임을 알고 있었다. 그리고 선택된 파일이 없으면 `e.target.files`의 값이 `null` 일 것이라고 생각하고 코드를 작성했다.

하지만 실제로는 선택된 파일이 없으면 `e.target.files`의 값이 `null`이 아니라 length가 0인 `FileList`가 된다. 그래서 선택한 파일이 없는 경우, **변수 `files`의 값**은 `null`이 아니라 length가 0인 `FileList`가 되어 if 문이 아니라 else 문의 코드가 실행되었던 것이다.

그러니까 애초에 선택된 파일이 없으면 `e.target.files`이 `null`이 될 거라는 잘못된 지식 기반으로 코드를 짜서 문제가 발생한 것이다. (MDN을 잘 읽어야 겠다는 생각이 들었다.)

그럼 `e.target.files` 값은 언제 `null`이 될까?
**file input의 경우** **files 속성의 값은 항상 `FileList`이다.** 선택된 파일이 없으면 단지 length가 0인 `FileList`일 뿐 `null`은 아니다.
**file input이 아닌 경우**에 **files 속성 값이 `null`이 된다**고 한다.

```tsx {5}
<StyledFileInput
  type="file"
  accept="image/png, image/jpeg"
  ref={fileInputRef}
  onChange={handleChangeProfileImageFile}
/>
```

그리고 `onChange` prop에 `handleChangeProfileImageFile` 함수를 전달하면 된다.

신기했던 점은 **file input의 경우**, `value`와 `onChange`을 함께 사용해 **controlled 컴포넌트 형태로 사용하지 않는다**는 점이다. file input의 경우, value 속성은 `"C:\fakepath\haaland.jpg"`처럼 file의 경로를 의미하고 실제로 선택된 File 객체를 의미하지 않는다. file input에서 change event가 발생했을 때, 변경된 파일 데이터는 value 속성이 아닌 files 속성에 있으므로 다른 타입의 input과 다르게 다룬다.

```ts
const handleSubmit: FormEventHandler<HTMLFormElement> = (e) => {
  e.preventDefault();

  window.alert(
    `[닉네임: ${nicknameField} / 이미지: ${profileImageField.type === "default" ? "기본 이미지" : profileImageField.file.name}] 프로필 생성 완료!`,
  );
};
```

마지막으로, 테스트를 위해 form을 제출하면 form 필드의 값을 표시하는 alert 창을 띄우도록 만들었다.

![profile-image-form-field-state-management](/images/posts/2023/image-preview-form/profile-image-form-field-state-management.webp)

아직 프리뷰 기능이 없어서, 파일이 잘 선택되었는지 시각적으로 확인할 수 없지만, **form을 제출했을 때 선택한 이미지 파일의 이름(haaland.jpg)을 잘 표시**하고 있다.

## 이미지 프리뷰

이제 파일을 변경할 때마다, 선택된 파일의 프리뷰를 표시하는 기능을 구현할 것이다.

`URL.createObjectURL(file)`과 `URL.revokeObjectURL(url)`을 사용할 것이다.

`URL.createObjectURL(file)`은 인자로 주어진 **object**(File, Blob 등)**를 가리키는 URL을 생성**하는 정적 메서드이다. 이 메서드로 선택된 파일을 가리키는 URL을 생성해 img 태그로 프리뷰를 표시할 것이다.

`URL.revokeObjectURL(url)`은 **생성한 URL을 해제**하는 역할을 한다. **메모리 누수를 막기 위해** 더 이상 사용하지 않는 URL은 이 메서드를 통해 해제해야 한다.

```tsx title="profile-create-form.tsx" showLineNumbers {1-3, 26-28, 35-36, 53-59}
type ProfileImage =
  | { type: "default" }
  | { type: "file"; file: File; previewURL: string };

export default function ProfileCreateForm() {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [nicknameField, setNicknameField] = useState("");

  const [profileImageField, setProfileImageField] = useState<ProfileImage>({
    type: "default",
  });

  const handleClickChangeImageButton = () => {
    if (!fileInputRef.current) return;
    fileInputRef.current.click();
  };

  const handleChangeNickname: ChangeEventHandler<HTMLInputElement> = (e) => {
    setNicknameField(e.target.value);
  };

  const handleChangeProfileImageFile: ChangeEventHandler<HTMLInputElement> = (
    e,
  ) => {
    if (profileImageField.type === "file") {
      URL.revokeObjectURL(profileImageField.previewURL);
    }

    const selectedFile = e.target.files?.[0];

    if (!selectedFile) {
      setProfileImageField({ type: "default" });
    } else {
      const previewURL = URL.createObjectURL(selectedFile);
      setProfileImageField({ type: "file", file: selectedFile, previewURL });
    }
  };

  const handleSubmit: FormEventHandler<HTMLFormElement> = (e) => {
    e.preventDefault();

    window.alert(
      `[닉네임: ${nicknameField} / 이미지: ${profileImageField.type === "default" ? "기본 이미지" : profileImageField.file.name}] 프로필 생성 완료!`,
    );
  };

  return (
    <StyledSection>
      <StyledHeading>프로필 만들기</StyledHeading>
      <StyledForm onSubmit={handleSubmit}>
        <StyledRelativeBox>
          <ProfileImagePreview
            previewSource={
              profileImageField.type === "file"
                ? profileImageField.previewURL
                : null
            }
          />
          <StyledAbsoluteBox>
            <ProfileImageDropdownMenu
              onClickDefaultImageButton={() => {}}
              onClickChangeImageButton={handleClickChangeImageButton}
            />
          </StyledAbsoluteBox>
        </StyledRelativeBox>
        <StyledFileInput
          type="file"
          accept="image/png, image/jpeg"
          ref={fileInputRef}
          onChange={handleChangeProfileImageFile}
        />
        <StyledFormField>
          <StyledLabel htmlFor="nickname">닉네임</StyledLabel>
          <StyledTextInput
            id="nickname"
            type="text"
            value={nicknameField}
            onChange={handleChangeNickname}
          />
        </StyledFormField>
        <StyledButton type="submit">만들기</StyledButton>
      </StyledForm>
    </StyledSection>
  );
}
```

위의 코드는, 프리뷰 기능을 추가한 `ProfileCreateForm` 컴포넌트 코드이다.

```ts {3}
type ProfileImage =
  | { type: "default" }
  | { type: "file"; file: File; previewURL: string };
```

먼저, 프리뷰 URL을 관리할 수 있도록 `ProfileImage` 타입을 수정했다.

```ts {4-6, 13-14}
const handleChangeProfileImageFile: ChangeEventHandler<HTMLInputElement> = (
  e,
) => {
  if (profileImageField.type === "file") {
    URL.revokeObjectURL(profileImageField.previewURL);
  }

  const selectedFile = e.target.files?.[0];

  if (!selectedFile) {
    setProfileImageField({ type: "default" });
  } else {
    const previewURL = URL.createObjectURL(selectedFile);
    setProfileImageField({ type: "file", file: selectedFile, previewURL });
  }
};
```

사용자가 파일을 선택한 경우 **선택한 파일을 가리키는 URL을 생성해** `profileImageField`를 업데이트 했다. 그리고 **file input에 change event가 발생했을 때, 직전에 파일을 선택한 상태였을 경우, 해당 파일을 가리키는 URL을 해제**했다.

```tsx
<ProfileImagePreview
  previewSource={
    profileImageField.type === "file" ? profileImageField.previewURL : null
  }
/>
```

파일이 선택된 경우 프리뷰를, 아닌 경우는 기본 이미지를 표시하도록 `ProfileImagePreview` 컴포넌트의 `previewSource` prop에 적절한 값을 전달했다.

![profile-image-form-field-preview](/images/posts/2023/image-preview-form/profile-image-form-field-preview.webp)

이제 이미지를 선택했을 때, 프리뷰 이미지가 표시된다.

## "기본 이미지" 메뉴를 클릭했을 때, 기본 이미지 선택 상태로 만들기(+file 상태 초기화)

```tsx title="profile-create-form.tsx" showLineNumbers {23-27, 32, 44-49, 73}
type ProfileImage =
  | { type: "default" }
  | { type: "file"; file: File; previewURL: string };

export default function ProfileCreateForm() {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const [nicknameField, setNicknameField] = useState("");

  const [profileImageField, setProfileImageField] = useState<ProfileImage>({
    type: "default",
  });

  const handleClickChangeImageButton = () => {
    if (!fileInputRef.current) return;
    fileInputRef.current.click();
  };

  const handleChangeNickname: ChangeEventHandler<HTMLInputElement> = (e) => {
    setNicknameField(e.target.value);
  };

  const clearPreviewURL = () => {
    if (profileImageField.type === "file") {
      URL.revokeObjectURL(profileImageField.previewURL);
    }
  };

  const handleChangeProfileImageFile: ChangeEventHandler<HTMLInputElement> = (
    e,
  ) => {
    clearPreviewURL();

    const selectedFile = e.target.files?.[0];

    if (!selectedFile) {
      setProfileImageField({ type: "default" });
    } else {
      const previewURL = URL.createObjectURL(selectedFile);
      setProfileImageField({ type: "file", file: selectedFile, previewURL });
    }
  };

  const handleClickDefaultImageButton = () => {
    clearPreviewURL();
    setProfileImageField({ type: "default" });
    if (!fileInputRef.current) return;
    fileInputRef.current.value = "";
  };

  const handleSubmit: FormEventHandler<HTMLFormElement> = (e) => {
    e.preventDefault();

    window.alert(
      `[닉네임: ${nicknameField} / 이미지: ${profileImageField.type === "default" ? "기본 이미지" : profileImageField.file.name}] 프로필 생성 완료!`,
    );
  };

  return (
    <StyledSection>
      <StyledHeading>프로필 만들기</StyledHeading>
      <StyledForm onSubmit={handleSubmit}>
        <StyledRelativeBox>
          <ProfileImagePreview
            previewSource={
              profileImageField.type === "file"
                ? profileImageField.previewURL
                : null
            }
          />
          <StyledAbsoluteBox>
            <ProfileImageDropdownMenu
              onClickDefaultImageButton={handleClickDefaultImageButton}
              onClickChangeImageButton={handleClickChangeImageButton}
            />
          </StyledAbsoluteBox>
        </StyledRelativeBox>
        <StyledFileInput
          type="file"
          accept="image/png, image/jpeg"
          ref={fileInputRef}
          onChange={handleChangeProfileImageFile}
        />
        <StyledFormField>
          <StyledLabel htmlFor="nickname">닉네임</StyledLabel>
          <StyledTextInput
            id="nickname"
            type="text"
            value={nicknameField}
            onChange={handleChangeNickname}
          />
        </StyledFormField>
        <StyledButton type="submit">만들기</StyledButton>
      </StyledForm>
    </StyledSection>
  );
}
```

위의 코드는, 기본 이미지 메뉴 기능을 추가한 최종 `ProfileCreateForm` 컴포넌트 코드이다.

```ts
const clearPreviewURL = () => {
  if (profileImageField.type === "file") {
    URL.revokeObjectURL(profileImageField.previewURL);
  }
};
```

먼저, 반복되는 코드를 줄이기 위해 생성한 URL을 해제하는 코드를 `clearPreviewURL` 함수로 분리했다.

```ts {2,3,5}
const handleClickDefaultImageButton = () => {
  clearPreviewURL();
  setProfileImageField({ type: "default" });
  if (!fileInputRef.current) return;
  fileInputRef.current.value = "";
};
```

"기본 이미지" 메뉴를 클릭했을 때 어떤 작업을 수행해야 할까?

일단 `setProfileImageField({ type: "default" })`로 `profileImageField` 상태를 기본 이미지가 선택된 상태로 만들어야 한다.

그리고, "기본 이미지" 메뉴가 클릭되기 전에 (이미지 파일이 선택되어) 프리뷰 URL이 존재할 수 있으므로 `clearPreviewURL()`도 호출해야 한다.

마지막으로 **꼭 필요한 작업은 file input을 초기화 하는 작업**이다. "기본 이미지" 메뉴를 눌렀다는 것은 기본 이미지를 선택하겠다는 의미도 있지만 아무런 파일이 선택되지 않은 상태로 만들겠다는 의미이고 이를 위해서는 file input 초기화 작업이 꼭 필요하다.

file input을 (초기의) 아무런 파일이 선택되지 않은 상태로 만들기 위해서는 file input element의 `files` 속성에 `null`이나 length가 0인 `FileList` 타입의 객체를 할당하는 것이 아니라 `value` 속성을 `""`(빈 문자열)로 할당해야 한다. (**`files`가 아니라 `value`의 값을 변경했다는 점이 신기했다.**)

만약 "기본 이미지" 메뉴를 클릭했을 때, file input 초기화 작업을 하지 않는다면?

```txt
홀란드 이미지 선택(A) -> 기본 이미지 버튼 클릭(B) -> 홀란드 이미지 선택(C)
```

위의 과정을 시뮬레이션하면, B -> C 과정을 진행할 때 홀란드 이미지가 새롭게 선택되지 않는 문제가 발생한다. (file input에 change event가 발생하지 않는다.)

왜 그럴까? B에서 기본 이미지 버튼을 누를 때 file input을 초기화 하지 않아서, 아직 file input 입장에서는 (A에서 선택한) 홀란드 이미지가 선택된 상황이다. 그래서 C의 과정에서 다시 홀란드 이미지를 선택해도 동일한 홀란드 이미지이기 때문에 change event가 발생하지 않았다. 따라서 file input의 초기화 과정이 꼭 필요하다.

![profile-image-form-field-default-image-button](/images/posts/2023/image-preview-form/profile-image-form-field-default-image-button.webp)

최종 결과물은 위와 같다. "홀란드 이미지 선택 -> 기본 이미지 버튼 클릭 -> 홀란드 이미지 선택 -> 제출" 했을 때, 프리뷰 이미지도 파일 선택 기능도 모두 잘 동작한다.

## 소감

file input을 다루면서 겪었던 문제들을 정리해봤다. 잘못된 지식을 바탕으로 틀린 코드를 작성하기도 했고, 일반적인 input과 다루는 방법이 살짝 달라서 신기하기도 했다.
22:T1b58,
## eslint 역할

코드를 분석해서 문제를 찾아주는 도구이다.

선언한 변수를 사용하지 않은 경우 등 코드 품질이 나빠지는 것을 예방할 수 있게 도와준다.

버그를 예방할 수 있게 도와준다.

코드를 (일관적인 스타일을 유지할 수 있게) 포맷팅 해준다.

## eslint 사용 방법

공식문서를 참고해 설치하고, 설정 파일을 작성한다.

`npx eslint yourfile.js` 형태의 명령어를 입력해 실행하면 된다.

- 콘솔창에 검사 결과가 표시된다.

에디터, IDE가 제공하는 **eslint extension**을 사용하면 매번 명령어를 입력해 실행하지 않아도 된다.

- 에디터가 밑줄로 실시간으로 오류를 표시해준다.
- 마치 정적 언어의 에디터가 프로그래머를 도와주는 것처럼 동작한다.

## eslint 설정

eslint를 사용하기 위해서는 `.eslintrc` 라는 이름의 설정 파일을 작성해야 한다.

- 확장자는 `.js`, `.json`, `.yml` 등 다양하다.

### rule

**코드를 검사할 규칙**

예시

- `no-const-assign` rule: `const` 키워드로 선언된 변수의 값을 변경하는지 검사하는 규칙

명시한 rule을 기반으로 eslint가 코드를 분석한다.

규칙 중 **fixable** 한 규칙들이 있다.

- eslint를 실행할 때 `--fix` option을 주면 fixable한 규칙을 위반한 경우, 알아서 고쳐준다.

### plugin

**rule을 정의한 패키지**

npm을 통해 third-party plugin을 설치하고, plugin에 정의된 rule, config 등을 사용할 수 있다.

예시

- `eslint-plugin-react`: 리액트와 관련된 rule을 정의한 패키지

**설정 파일에 plugin을 추가하는 것은 eslint의 동작에 아무런 영향을 미치지 않는다.**

```json title=".eslintrc.json"
{
  "plugins": ["react", "react-hooks"]
}
```

`eslint-plugin-react`, `eslint-plugin-react-hooks` plugin을 추가했다.

패키지 이름에 `eslint-plugin-` prefix가 붙는다.

plugin을 추가할 때, `eslint-plugin-` prefix는 생략할 수 있다.

**plugin에 의해 정의된 rule, config를 사용해야 eslint가 동작한다.**

```json title=".eslintrc.json"
{
  "plugins": ["react", "react-hooks"],
  "rules": {
    "react/jsx-uses-react": "off",
    "react/react-in-jsx-scope": "off",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

`"rules"`에 rule을 명시할 때는 **"`eslint-plugin-` prefix를 제외한 plugin 이름/rule 이름"** 형태로 명시한다.

- `"react-hooks/rules-of-hooks"`
  - `eslint-plugin-react-hooks` plugin의 `rules-of-hooks` rule 사용

### plugin에 정의된 config 사용

plugin을 추가하고, plugin에 정의된 rule을 하나씩 추가하는 것은 번거롭다.

그래서 대부분 plugin은 `recommended`, `all` 같은 config(eslint 설정 파일, `shareable config`)를 제공한다.

설정 파일의 `extends`에 `plugin`이 제공하는 `config`를 명시하면 된다.

```json title=".eslintrc.json"
{
  "extends": ["plugin:react/recommended"]
}
```

`eslint-plugin-react`가 제공하는 recommended config, 즉 미리 설정해둔 rule들을 사용한다는 의미이다.

`eslint-plugin-react`가 제공하는 recommended config 내에 `eslint-plugin-react` plugin이 추가되어 있고 rule들이 설정되어 있기 때문에, 별도로 `eslint-plugin-react`를 추가할 필요가 없다. (`"plugins"` 없이 `"extends"`만 써도 된다.)

### config(shareable config)

**이미 정의된 eslint 설정을 가져와서 사용할 수 있다.** (plugin과 rule들이 설정되어 있다.)

`eslint-config-*` 형태의 이름을 가지는 패키지이다.

예시

- `eslint-config-prettier`: **prettier와 충돌하는 eslint rule들**을 비 활성하는 설정을 담은 패키지

`"extends"`를 이용해 이미 정의된 config를 사용할 수 있다.

```json title=".eslintrc.json"
{
  "extends": ["eslint:recommended", "plugin:react/recommended", "prettier"]
}
```

plugin이 제공하는 config는 "plugin:plugin이름/plugin이 제공하는 config이름" 형태로 작성한다.

- `eslint-plugin-react`가 제공하는 recommended config => `"plugin:react/recommended"`

`eslint-config-*` 형태의 config는 `"*"`를 작성한다.

- `eslint-config-prettier` config => `"prettier"`

## prettier 역할

코드 포맷터로서, 일관적인 코드 형태를 유지할 수 있게 도와준다.

- comma 스타일, 코드 한 줄의 최대 길이 등을 일관되게 유지한다.
- 코드의 외적인 형태를 일관적으로 유지한다.

코드 포맷팅 하는 부분에서 eslint와 역할이 겹친다.

보통 eslint로 코드 품질을 검사하고, prettier로 코드 포맷팅을 한다.

## prettier 사용 방법

공식 문서를 참고해 설치하고, 설정 파일을 작성하면 된다.

`npx prettier --write .` 커맨드를 통해 프로젝트 전체를 포매팅할 수 있다.

prettier는 `js`, `jsx` 파일 뿐만 아니라, `html`, `css`, `md` 파일 등에도 사용할 수 있다.

## eslint와 prettier 함께 사용하기

eslint와 prettier를 함께 사용하기 위해서는 eslint에 `eslint-config-prettier`를 추가해야 한다.

- 필요 없거나 prettier와 충돌할 가능성이 있는 eslint rule들을 비활성 시키는 eslint 설정이다.
- `eslint-config-prettier` 패키지의 ReadMe를 참고해 eslint 설정 파일에 설정하면 된다.

## eslint, prettier 사용 자동화 (git hook, husky, lint-staged)

### 상황

eslint와 prettier를 사용함으로써, 코드 품질 검사와 코드 포맷팅을 편리하게 할 수 있다.

하지만 commit 하기 전에 매번 명령어를 입력해 eslint와 prettier를 실행시켜줘야 한다. 번거롭고 잊어버릴 수 있다.

### git hook, husky를 이용해 커밋 직전에 eslint, prettier 사용

git은 어떤 이벤트가 생겼을 때, hook을 이용해 특정 스크립트를 실행할 수 있다.

예를 들면, pre-commit hook은 commit 할 때 가장 먼저 호출된다.
따라서 eslint와 prettier를 사용하는 명령어를 pre-commit hook으로 등록해 사용하면 된다.

이때, hook으로 등록한 작업에 실패하면, commit은 취소된다. pre-commit hook 으로 eslint를 등록한 경우: eslint로 코드를 검사했을 때 문제가 있다면, commit이 취소된다.

husky는 git hook을 편리하게 사용할 수 있도록 도와주는 패키지이다.

### lint-staged: 변경된 파일에만 linter 적용

husky를 통해 commit 직전에 eslint, prettier를 실행시킬 수 있지만, 프로젝트 내부의 모든 파일(변경사항이 없는 파일을 포함해서)에 대해 실행되기 때문에 비효율적이다.

**lint-staged는 변경된 파일들에 대해서만 linter를 적용한다.**

lint-staged를 통해 eslint와 prettier를 실행시키고, lint-staged를 pre-commit hook으로 등록해 사용하면, 변경된 파일에 대해서만 eslint, prettier를 적용할 수 있다.
23:T987,
## Webpack Dev Server

### 필요성

개발 서버 없이 개발한다면, 코드를 변경하고 직접 빌드한 뒤, 빌드 결과물을 웹 브라우저를 통해 확인해야 한다.

- 매번 **코드 변경 -> 직접 빌드 -> 빌드 결과물을 웹 브라우저에서 확인하는 과정**을 수행하는 것은 번거롭다.

webpack이 제공하는 개발 서버를 사용하면 매번 직접 빌드하고, 새로운 빌드 결과물을 웹 브라우저로 열어서 확인할 필요가 없다.

- 빌드 결과물을 직접 웹 브라우저로 열 필요가 없다. 대신 개발 서버를 통해 빌드 결과를 확인할 수 있다.
- **개발 서버가 파일의 변경 사항을 감지하고 알아서 reloading 해준다.**

### 설정

```js title="webpack.config.js"
module.exports = {
  // ...
  devServer: {
    port: 3000, // 개발 서버가 실행될 port.
    historyApiFallback: true,
    open: true, // 개발 서버 구동 후, 웹 브라우저를 실행하라는 옵션.
  },
};
```

`historyApiFallback` 옵션

SPA(Single Page Application) 개발하면서 라우팅 기능을 사용하는 경우, 주로 `true`로 설정한다.

클라이언트에서 **React Router** 등에서 정의한 주소를 웹 브라우저의 주소창에 입력하면, 실제 서버에는 해당 주소가 존재하지 않기 때문에 `404` 상태 코드로 응답한다.

- 이런 경우 `index.html`로 리다이렉트 해서 문제를 해결해주는 옵션이다.

### 실행

`npx webpack serve` 명령어를 통해 실행할 수 있다.

주로 npm script로 등록해 사용한다.

```json title="package.json"
{
  "scripts": {
    "dev": "webpack serve"
  }
}
```

## HMR(Hot Module Replacement)

### HMR 필요성

개발 서버만 사용하면 파일을 변경했을 때, 웹 브라우저 화면 전체가 reloading 된다.

- 변경한 컴포넌트와 관련 없는 컴포넌트들의 상태도 모두 초기화된다.
- 개발용으로 설정한 데이터도 모두 초기화된다. 불편하다.

**Webpack Dev Server**의 **HMR** 기능과 **React Refresh Webpack Plugin**을 함께 사용하면 변경된 React 컴포넌트의 변경 사항만 반영한다.

### HMR 설정

**React Refresh Webpack Plugin** ReadMe를 확인해 설정하면 된다.

**Webpack Dev Server** 버전 `4`부터 **HMR**이 기본적으로 `enabled` 되어있으므로 **Webpack Dev Server** 설정은 별도로 수정할 게 없다.
24:T1576,
## 역할

최신 js 문법을 사용해서 개발하더라도, 여러 웹 브라우저와 호환될 수 있도록 적당한 하위 버전의 js로 변환하는 것이 Babel의 역할이다.

- 최신버전의 js -> ES5
- 타입스크립트 -> ES5
- jsx -> ES5

## 동작 방식

파싱 -> 변환 -> 출력

- 파싱: 코드를 트리 형태의 자료구조로 변환
- 변환: 파싱된 트리를 변경하며, 실제 코드 변환
- 출력: 변경된 결과물을 출력

## plugin

Babel 자체는 파싱과 출력을 담당한다.

실제 변환은 **plugin**이 수행한다.

설정 파일 혹은 명령어 옵션으로 plugin을 명시하면서 babel을 실행하면 plugin에 의해 변환된 코드가 출력된다.

## preset

실제 변환을 하는 plugin을 일일이 하나씩 추가하는 것은 **번거롭다.**

미리 여러 plugin을 묶어 둔 것은 preset이라고 한다.

대표적인 preset에는

- preset-env
- preset-react
- preset-typescript

가 있다.

JavaScript를 쓰면서 React를 이용해 개발하려면, 직접 plugin을 찾아서 설정하기보다는 preset-env와 preset-react를 사용하면 된다.

### preset-env

target browser 환경을 세세하게 신경 쓰지 않고, JavaScript의 최신문법을 사용해 개발할 수 있게 도와준다.

즉, 최신 JavaScript 문법을 사용해 개발된 코드를 target browser에서 동작할 수 있게 변환해준다.

### preset-react

React 코드를 변환한다.

### preset-typescript

TypeScript 코드를 변환한다.

## Webpack과 통합해 사용하기

Babel을 별도로 실행해서 사용하기보다 **Webpack에 통합해서 사용**하면 편하다.

Webpack의 loader 중 **babel-loader**를 이용하면, Webpack을 통해 Babel을 사용할 수 있다.

```js title="webpack.config.js"
module.exports = {
  module: {
    rules: [
      {
        // .js, .jsx 파일에 babel loader를 적용한다.
        test: /\.jsx?$/,
        use: ["babel-loader"],
        /* 
          변환이 필요 없는 파일(node_modules 디렉터리의 파일들)에
          Babel이 적용되는 것을 막아서 babel-loader가 느려지지 않게 한다.
        */
        exclude: /node_modules/,
      },
    ],
  },
};
```

## babel-loader 설정하기

babel-loader의 options으로 Babel 설정을 할 수 있다.

별도의 babel 설정 파일을 만드는 대신, Webpack 설정 파일에 babel-loader를 명시하면서 babel 설정을 한다.

### preset-env 설정하기

```js title="webpack.config.js"
module.exports = {
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: [
          {
            loader: "babel-loader",
            options: {
              presets: [
                [
                  "@babel/preset-env",
                  {
                    useBuiltIns: "usage",
                    corejs: "3",
                  },
                ],
              ],
            },
          },
        ],
        exclude: path.resolve(__dirname, "node_modules"),
      },
    ],
  },
};
```

babel-loader의 options에 Babel 설정을 했다.

preset-env를 preset으로 추가했다.

preset-env의 **target 옵션**을 추가하거나, **browserslist 설정**으로 **target이 되는 웹 브라우저 환경**을 명시해야 한다.

- 위의 경우는 **target 옵션**을 안 주고, 대신 **browserslist 설정**을 한 경우이다.
- **browserslist**는 `package.json`에 설정하면 된다.

폴리필(polyfill) 설정하기

- **useBuiltIns 옵션**은 `"entry"`와 `"usage"` 값을 가질 수 있는데, `"usage"`로 설정하면 필요한 폴리필만 추가한다.
- corejs는 폴리필을 제공한다.
- corejs 옵션으로 corejs 버전을 명시한다.

**폴리필 vs. 트랜스파일**

- Babel 자체는 트랜스파일러로, 최신 js 코드를 예전 표준을 준수하는 코드로 변환시켜, 타겟 환경에서 실행될 수 있게 한다.
- js는 표준에 **새로운 문법**이나 **새로운 내장 함수에 대한 정의**가 포함되면서 발전하고 있다.
  - 프로그래머가 **새로운 문법**으로 코드를 작성하면, 트랜스파일러가 예전 표준을 준수하는 코드로 변경해준다.
  - 하지만, **예전 표준을 지원하는 웹 브라우저**에서, 새 표준에 추가된 **새로운 내장 함수**를 실행하기 위해서는 명세서를 읽고 해당 내장 함수를 직접 구현해 스크립트에 추가해야 한다.
    - 이렇게 새롭게 구현해야 할 코드를 폴리필이라고 한다.
  - corejs는 폴리필을 제공한다.
- preset-env가 target 웹 브라우저 환경에 맞게 필요한 corejs(폴리필)을 추가(import)한다.

### preset-react 설정하기

```js title="webpack.config.js"
module.exports = {
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: [
          {
            loader: "babel-loader",
            options: {
              presets: [
                [
                  "@babel/preset-react",
                  {
                    runtime: "automatic",
                  },
                ],
              ],
            },
          },
        ],
        exclude: path.resolve(__dirname, "node_modules"),
      },
    ],
  },
};
```

babel-loader의 options에 Babel 설정을 했다.

preset-react를 preset으로 추가했다.

`runtime: "automatic"` 옵션은 React 코드를 작성할 때, 매번 `import React from "react"` 코드를 작성하지 않기 위함이다.
25:T14d1,
## 번들러(Bundler)

`Webpack`, `Rollup`, `Parcel` 등이 있다.

### 역할

여러 개의 파일을 하나로 합쳐준다.

개발할 때는 모듈을 활용해 여러 파일로 분리해 개발한다.

배포할 때는 **시작점이 되는 파일**(**entry**)로부터 모든 의존하는 모듈들을 합쳐 하나의 파일로 만든다.

### 필요성

최신 웹 브라우저는 이미 모듈을 지원한다. 그런데 굳이 번들러를 사용해 하나의 파일로 만들 필요가 있을까?

- 아직 모듈을 지원하지 않는 웹 브라우저도 있다.
- 웹 브라우저가 여러 개의 js 파일(모듈을 사용하므로 여러 개의 파일)을 동시에 로딩하는 것은 속도(성능)에 문제가 발생할 수 있다.
  - 중간에 하나의 js 파일이라도 로딩이 지연되면 전체적으로 지연될 수 있다.
  - 그래서 번들러를 통해 하나의 파일로 합쳐서 웹 브라우저에게 제공하는 방식으로 배포한다.

## Webpack 설정하기

Webpack을 사용해 번들링 하기 위해서는 webpack 명령어를 실행하면서 mode, entry, output 같은 옵션을 주면 된다.

보통, 설정해야 할 옵션이 많으므로 명령어를 입력하면서 모든 옵션을 인자(argument)로 명시하기 힘들다. 그래서 `webpack.config.js` 같은 설정 파일을 별도로 만든다. (js 파일로, 설정을 담은 객체를 export 하면 된다.)

### mode 설정

```js title="webpack.config.js"
// Webpack은 node 환경에서 실행된다.
// process.env.NODE_ENV를 통해 NODE_ENV 라는 환경 변수를 참조할 수 있다.
const isDevelopment = process.env.NODE_ENV !== "production";

module.exports = {
  mode: isDevelopment ? "development" : "production",
};
```

`"development"` 또는 `"production"` 중 하나로 설정한다.

개발할 때는 `"development"`로, 배포할 때는 `"production"`을 사용한다.

설정한 mode(환경)에 맞게 webpack이 기본적인 최적화를 한다.

### entry 설정

```js title="webpack.config.js"
module.exports = {
  entry: {
    // key - value 형태로 지정한다.
    // value에 entry 가 될 파일 이름을 작성한다.
    // key는 번들링 된 결과물의 이름을 만들 때 사용된다.
    app: "./src/main",
  },
};
```

**말 그대로 시작점(entry)이 되는 모듈**을 지정한다.

React를 사용할 때는 App 컴포넌트를 root container에 렌더링하는 모듈이 entry가 된다. (주로 main.jsx 혹은 index.jsx 라는 이름이 붙은 파일)

### output 설정

```js title="webpack.config.js"
module.exports = {
  output: {
    // 번들링 된 결과물이 저장될 위치
    // 절대 경로를 사용해야 한다.
    // node가 제공하는 path 모듈을 사용한다.
    path: path.resolve(__dirname, "dist"),
    // 번들링 된 결과물의 이름
    // [name] 은 엔트리의 key를 의미한다.
    // 즉 이 경우, dist 폴더 내부의 assets 폴더 내에 app.js가 생성된다.
    filename: "assets/[name].js",
    // 매번 빌드 전에 output 폴더를 정리한다.
    clean: true,
  },
};
```

번들링 된 결과물이 저장될 **위치**를 지정한다.

**번들링 된 결과물의 이름**을 지정한다.

### loader 설정

원래 Webpack은 js 파일과 JSON 만 처리 가능하다.

loader를 사용하면 다른 형태의 파일도 Webpack이 처리할 수 있으며, 유효한 모듈 형태로 변환할 수 있다. (변환된 모듈은 앱 내에서 사용할 수 있으며, 자연스럽게 의존성 그래프에도 추가된다.)

loader를 통해 js 뿐만 아니라 css, image, font 등도 모듈로 인식하여, js 파일에서 import 해 사용할 수 있다.

Webpack은 기본적으로 모든 파일을 모듈로 생각한다.

```js title="webpack.config.js"
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/, // css 파일에 대해, 아래 명시한 loader들을 적용한다.
        /* 
          loader는 배열의 역순으로 적용된다.
          개발환경이라면,
          postcss-loader -> css-loader -> style-loader 순으로 적용된다.
        */
        use: [
          isDevelopment ? "style-loader" : MiniCssExtractPlugin.loader,
          "css-loader",
          "postcss-loader",
        ],
      },
    ],
  },
};
```

module.rules에 배열 형태로 설정한다.

배열의 원소는 test, use 프로퍼티를 가지는 객체 형태이다.

- test에는 어떤 파일을 대상으로 loader를 적용할지 명시한다.
- use에는 어떤 loader를 이용해 변환할지 명시한다.

### plugin 설정

loader가 다양한 형태의 파일을 유효한 모듈로 변환하는 데 사용되는 반면, plugin은 좀 더 광범위한 task를 처리하는 데 사용된다.

즉, 번들 된 결과물을 처리한다.

환경 변수 주입, 번들 최적화, 번들 난독화 등을 할 수 있다.

```js title="webpack.config.js"
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  plugins: [
    // plugin은 class 형태이므로 인스턴스를 생성해주면 된다.
    new HtmlWebpackPlugin({
      template: "public/index.html",
    }),
  ],
};
```

plugins에 배열 형태로 설정한다.

plugin은 class 이므로 new 연산자를 통해 인스턴스를 생성하면 된다.
b:["$","main",null,{"className":"max-w-(--content-max-width) mx-auto px-(--content-horizontal-padding) flex flex-col gap-6","children":[["$","h2",null,{"className":"font-bold text-2xl","children":"글"}],["$","$13",null,{"fallback":null,"children":["$","$L16",null,{"posts":[{"mdxContent":"$17","createdAt":"$D2025-07-23T07:07:52.000Z","updatedAt":"$undefined","description":"다익스트라 알고리즘에 대해 학습한 내용 정리","title":"다익스트라 알고리즘","tags":["algorithm","C++"],"seriesId":"$undefined","id":"2025/dijkstra-algorithm"},{"mdxContent":"$18","createdAt":"$D2025-07-22T07:14:00.000Z","updatedAt":"$undefined","description":"\"C++\"이라는 search parameter가 왜 \"C  \"로 해석되었을까?","title":"URL 디코딩 관련 문제 해결","tags":["Next.js","Troubleshooting"],"seriesId":"$undefined","id":"2025/url-decoding-troubleshooting"},{"mdxContent":"$19","createdAt":"$D2025-07-17T05:51:41.000Z","updatedAt":"$undefined","description":"플로이드 알고리즘에 대해 학습한 내용 정리","title":"플로이드 알고리즘","tags":["algorithm","C++"],"seriesId":"$undefined","id":"2025/floyd-algorithm"},{"mdxContent":"$1a","createdAt":"$D2025-07-12T06:50:42.000Z","updatedAt":"$undefined","description":"type annotation을 사용했을 때와 satisfies를 사용했을 때의 차이점은 무엇일까?","title":"타입스크립트 satisfies 연산자","tags":["TypeScript"],"seriesId":"$undefined","id":"2025/satisfies-operator"},{"mdxContent":"$1b","createdAt":"$D2025-06-03T11:33:07.000Z","updatedAt":"$undefined","description":"Union-Find 자료구조에 대해 학습한 내용 정리","title":"Union-Find (Disjoint-set)","tags":["algorithm","C++"],"seriesId":"$undefined","id":"2025/union-find"},{"mdxContent":"$1c","createdAt":"$D2025-02-08T10:14:40.000Z","updatedAt":"$undefined","description":"이진 탐색, lower bound, upper bound 등에 대해 정리","title":"이진 탐색 (Binary Search)","tags":["algorithm"],"seriesId":"$undefined","id":"2025/binary-search"},{"mdxContent":"$1d","createdAt":"$D2024-12-04T04:43:06.000Z","updatedAt":"$undefined","description":"글 상세 페이지에서 사용할 TOC 컴포넌트 개발 후기","title":"TOC(Table of Contents) 컴포넌트 만들기","tags":["Next.js","React","회고"],"seriesId":"개인 웹 사이트 개발","id":"2024/toc"},{"mdxContent":"$1e","createdAt":"$D2024-06-12T11:00:00.000Z","updatedAt":"$undefined","description":"Vite 기반의 React 컴포넌트 라이브러리 개발 환경 설정 후기","title":"라이브러리 개발 환경 설정 회고 (Rollup -> Vite 마이그레이션)","tags":["React","Vite","개발 환경 설정","회고"],"seriesId":"업무 회고록","id":"2024/lib-configuration-based-on-vite"},{"mdxContent":"$1f","createdAt":"$D2024-01-16T11:00:00.000Z","updatedAt":"$D2025-09-07T03:30:00.000Z","description":"입력값에 따라 너비가 알아서 늘어나고 줄어드는 input React 컴포넌트를 만들면서 겪었던 시행착오 정리","title":"입력값에 따라 너비가 늘어나고 줄어드는 input React 컴포넌트 만들기","tags":["React","회고"],"seriesId":"업무 회고록","id":"2024/auto-resize-input"},{"mdxContent":"$20","createdAt":"$D2023-11-18T09:00:00.000Z","updatedAt":"$undefined","description":"MobX 핵심 개념 및 React와 함께 사용하는 방법 정리","title":"MobX 사용 후기","tags":["MobX","React","상태 관리"],"seriesId":"업무 회고록","id":"2023/how-to-use-mobx"},{"mdxContent":"$21","createdAt":"$D2023-10-11T11:00:00.000Z","updatedAt":"$undefined","description":"프로필 생성/편집 form을 개발하면서 겪었던, 이미지 파일 관련 문제 해결 과정을 정리","title":"form에서 이미지 파일 선택 상태 관리 및 이미지 파일 프리뷰 기능 구현","tags":["React","회고"],"seriesId":"업무 회고록","id":"2023/image-preview-form"},{"mdxContent":"$22","createdAt":"$D2022-09-26T08:00:00.000Z","updatedAt":"$undefined","description":"eslint, prettier, husky, lint-staged 사용 방법 정리","title":"React 개발 환경 직접 설정하기: eslint, prettier","tags":["React","개발 환경 설정"],"seriesId":"React 개발 환경 직접 설정하기","id":"2022/eslint-prettier-configuration"},{"mdxContent":"$23","createdAt":"$D2022-09-26T07:00:00.000Z","updatedAt":"$undefined","description":"Webpack Dev Server 설정 방법 정리","title":"React 개발 환경 직접 설정하기: Webpack Dev Server, HMR","tags":["React","Webpack","개발 환경 설정"],"seriesId":"React 개발 환경 직접 설정하기","id":"2022/webpack-dev-server-hmr"},{"mdxContent":"$24","createdAt":"$D2022-09-26T06:00:00.000Z","updatedAt":"$undefined","description":"Babel에 대해 공부한 내용 정리","title":"React 개발 환경 직접 설정하기: Babel","tags":["Babel","React","개발 환경 설정"],"seriesId":"React 개발 환경 직접 설정하기","id":"2022/babel-configuration"},{"mdxContent":"$25","createdAt":"$D2022-09-26T05:00:00.000Z","updatedAt":"$undefined","description":"Webpack에 대해 공부한 내용 정리","title":"React 개발 환경 직접 설정하기: Webpack","tags":["React","Webpack","개발 환경 설정"],"seriesId":"React 개발 환경 직접 설정하기","id":"2022/webpack-configuration"}],"tags":["algorithm","Babel","C++","MobX","Next.js","React","Troubleshooting","TypeScript","Vite","Webpack","개발 환경 설정","상태 관리","회고"]}]}]]}]
